[{"content":" # 字符串基本使用 # 声明和初始化字符串 在Go中要声明一个字符串可以这样：\n1 2 3 var s string s := \u0026#34;hello world\u0026#34; s := \u0026#34;你好\u0026#34; //Go也支持中文字符串 # 格式化输出 在Go中格式化输出字符串主要使用fmt包中的Printf和Sprintf，例如：\n1 2 3 4 a := \u0026#34;世界\u0026#34; fmt.Printf(\u0026#34;hello,%s\u0026#34;, a) str := fmt.Sprintf(\u0026#34;hello,%s\u0026#34;, a) fmt.Println(str) 注意：Sprintf会返回格式化后的字符串，而Printf仅仅只能打印\n# 字符串编码 Go中字符串使用的是UTF-8编码的Unicode字符序列，需要注意的是在编写Go代码时，需要将编辑器保存设置为UTF-8格式，否则可能会出现编译错误。\n在Go中汉字通常占3个字节，而英文字母只需要1个。\n# 字符串相关函数 Go中字符串相关的函数都在strings包中\n前缀后缀 1 2 3 4 //判断字符串s前缀是否是prefix HasPrefix(s, prefix string) bool //判断字符串s后缀是否是suffix HasSuffix(s, suffix string) bool 是否包含 1 2 3 4 5 6 //字符串s是否包含子串substr Contains(s string, substr string) bool //字符串是否包含chars内任一字符 ContainsAny(s string, chars string) bool //字符串是否包含某一字符 ContainsRune(s string, r rune) bool 判断索引位置 1 2 3 4 //返回字符串s中第一个substr的位置，如果没有找到返回-1 Index(s, substr string) int //返回字符串s最后一个substr的位置，如果没有找到返回-1 LastIndex(s, substr string) int 字符串替换 1 2 3 4 5 6 7 8 //将字符串s的前n个字符串old替换为new，返回新字符串，如果n=-1则替换所有的new为old Replace(s, old, new string, n int) string //例子: s := \u0026#34;hello,world\u0026#34; new := strings.Replace(s, \u0026#34;l\u0026#34;, \u0026#34;j\u0026#34;, -1) //把s中的所有\u0026#39;l\u0026#39;替换为\u0026#39;j\u0026#39; fmt.Println(s, new) //输出: hello,world hejjo,worjd 字符串计数 1 2 //返回s中出现substr的次数，如果substr为空，则返回len(s)+1 Count(s, substr string) int 大小写转换 1 2 3 4 //将字符串s转换为小写字母返回 ToLower(s string) string //将字符串s转换为大写字母返回 ToUpper(s string) string 修剪字符串 1 2 3 4 5 6 7 8 //剔除掉字符串s前后的cutset Trim(s, cutset string) string //仅剔除字符串s开头的cutset TrimLeft(s, cutset string) string //仅剔除字符串s结尾的cutset TrimRight(s, cutset string) string //剔除字符串s开头结尾的空格 TrimSpace(s string) string 分割和拼接 1 2 3 4 5 6 //将字符串s以空白字符为分隔符切分成数组 Fields(s string) []string //将字符串s以sep为分隔符切分成数组 Split(s, sep string) []string //将字符串数组elems使用sep拼接 返回新字符串 Join(elems []string, sep string) string # 字符串底层原理 # 字符串数据结构 在Go中字符串的底层实际上是一个struct：\n1 2 3 4 type StringHeader struct { Data uintptr Len int } 字符串结构体有一个byte数组指针和一个代表长度的len。\nGo使用\u0026quot;\u0026quot;来声明单行字符串，```来声明多行字符串。\n1 2 3 s1 := \u0026#34;hello world!\u0026#34; s2 := `hello world!` 在Go中string类型是不可变的，在分配内存时会被分配到只读区域，同样在其他语言中字符串类型也是不可变的，这样做的原因是：\n安全：大部分密码都是以字符串形式存储，如果可以修改会造成安全漏洞\n性能：通常HashMap的key一般会是字符串，字符串不可变就能进行hashcode缓存避免重复计算\nGo中并没有字符串常量池这种设计，意味着每次创建相同的字符串会重复分配内存，在某些情况下可能会成为瓶颈，可以自己实现字符串常量池来避免。\n如果需要对字符串强行进行修改，如果字符串只包含ASCII码以内的字符，可以先转换为[]byte类型，在进行修改，再转换为字符串。但是这种方式并没有改变内存中的不可变区域，而是在新的内存区域。\n# 单引号和双引号的区别 在Go中单引号和双引号是由本质区别的，单引号 — rune类型，其实就相当于int32类型，占4个字节，在Unicode编码中最大4个字节就能表示一个字符。比方说：fmt.Println('a') 结果是97，是ASCII码表中的a的值。双引号—string类型，在Go中双引号表示字符串类型，Go 语言中字符串默认是 UTF-8 编码的 Unicode 字符序列，也就是byte数组\n# rune和string异同点 类型 rune（单引号） string（双引号） 底层类型 int32 byte数组 是否能互相转换 是 是 是否可变 不可变 不可变 ","date":"2024-03-29T18:36:49+08:00","permalink":"https://bitfrost7.github.io/p/golang/string/","title":"Golang学习-字符串"},{"content":" # Go中的数据类型介绍 在Go中数据类型分为3大类：基础类型，如int，float，bool这些基础类型。内置类型，比如slice，map，channel这些。派生类型，从基础类型或者内置类型组合自定义出来的类型，也可以看作Go中的\u0026quot;对象\u0026quot;。\n字长：计算机CPU总线的位宽，一般有32位和64位，限制了cpu一次能读取的数据\n字节：一位0或者1就是1bit，1byte = 8bit，1024 byte = 1kb， 1024 kb = 1 MB，1024 MB = 1GB # 数字类型 在Go中int 类型的大小是根据底层系统的字长决定，32位系统下是4字节，64位系统下是8字节。而固定位数的整型类型有8种:\n类型 描述 大小 表示范围 零值 int8 8 位整型 1字节 -2^7 ~ 2^7-1 0 int16 16位整型 2字节 -2^15 ~ 2^15-1 0 int32 32位整型 4字节 -2^31 ~ 2^31-1 0 int64 64位整型 8字节 -2^63 ~ 2^63-1 0 uint8 无符号8 位整型 1字节 0~255 0 uint16 无符号16位整型 2字节 0 ~ 2^16-1 0 uint32 无符号32位整型 4字节 0~2^31-1 0 uint64 无符号64位整型 8字节 0~2^63-1 0 这8种都与系统无关。好处是节省空间，大小可选择；缺点是移植性不好。\n# 浮点型 浮点型有2种：\n类型 描述 大小 表示范围 float32 32位浮点型数 4字节 -3.403E38~3.403E38 float64 64位浮点型数 8字节 -1.798E308~1.798E308 计算机中浮点数的保存通常都是近似值，可能因为精度问题而导致比较结果不准确。所以比较浮点数的零值或者两个浮点数是否相等一般采用math.Abs来比较。\n# 自定义类型 在Go中使用struct 和 type 关键字来自定义类型，这些类型由基本类型组成，Go使用_组合_的概念来替代_对象。_\nGo中结构体的内存排列是紧密的，但也有例外，不同的类型组合可能会导致结构体大小占用不一样。\n# 内存对齐 CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。 这么设计的目的，是减少 CPU 访问内存的次数，提升 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。\n内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后， 对该变量的访问就是原子的，这个特性在并发场景下至关重要。\n内存对齐提升性能的同时，也需要付出相应的代价。由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以 占用的内存会更大，这也是典型的 空间换时间 策略。\nGo中内存对齐规则(一个字32位下是4字节，64位下是8字节)：\n类型 大小 bool 1 个字节 intN, uintN, floatN, complexN N / 8个字节（例如 float64 是 8 个字节） int, uint, uintptr 1 个字 *T 1 个字 string 2 个字 （数据、长度） []T 3 个字 （数据、长度、容量） map 1 个字 func 1 个字 chan 1 个字 interface 2 个字 （类型、值） # example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1 word(字) = 8byte(字节) // 未对齐 type StructA struct { sex bool // 1字节 对齐到1个字 name string // 16字节 对齐到2个字 age int16 // 2字节 对齐到1个字 } // 对齐 type StructB struct { name string // 16字节 对齐到2个字 age int16 // 2字节 对齐到1个字 sex bool // 1字节 对齐到1个字 } func main() { fmt.Println(\u0026#34;structA length:\u0026#34;, unsafe.Sizeof(structA{})) // output: 32 fmt.Println(\u0026#34;structB length:\u0026#34;, unsafe.Sizeof(structB{})) // output: 24 } ","date":"2024-03-29T18:30:03+08:00","permalink":"https://bitfrost7.github.io/p/golang/type/","title":"Golang学习-基础数据类型"},{"content":" # Array数组 Golang中的数组是静态的，存储着一段相同内容的连续空间。\n# 基本使用 # 声明和初始化 在Go中数组的初始化主要有两种方式：一种是显示的指定数组大小，另一种是使用[...]自动推导数组大小的方式。\n1 2 arr1 := [3]int{1,2,3} arr2 := [...]int{1,2,3} 以上两种方式运行结果是一样的，后一种方式会在编译期间自动推导成第一种，只是Go为我们提供的语法糖。\nGo编译器在初始化数组时，会根据字面量的多少来进行不同的优化：\n当元素的数量小于或等于4个时，会将数组的元素直接放在栈上。\n当元素的数量大于4个时，会将数组中元素放置在静态区并在运行时取出。\n# 访问和读写 数组使用arr[n]来访问数组内元素，如果是一些简单的数组或者字符串的越界错误会在编译期间发现，而如果使用变量去访问数组，会在运行时触发程序的错误并导致崩溃退出。\n# 多维数组使用 在Go多维数组的初始化和一维类似：\n1 arr := [2][3]int{{1,2,3},{4,5,6}} # Slice切片 # 定义和初始化 切片是Go提供的基于array的一种动态数组，其长度并不像数组那样固定，我们可以向切片中追加元素或者进行扩容等操作。\n切片的初始化有三种方式：\n通过下标初始化获得切片或者数组的一部分\n使用字面量初始化新的切片\n使用关键字make来创建切片\n1 2 3 4 slice := arr[2:3] slice := []int{1,2,3} slice := make([]int,3) //make时还可以传入cap参数，当然，Go也会对参数进行校验，cap必须大于等于len 当Go编译器在创建切片时：\n如果切片发生逃逸或者切片的大小或容量特别大时，需要在运行时在堆上创建底层数组和切片。\n当切片特别小时，Go编译器会先在栈上或者静态存储区初始化数组，再通过下标(即第一种arr[2:3]的方式)得到切片。\n在运行时创建切片时，编译器会计算切片所需要的空间并在堆上申请一片连续的内存空间(空间不足会panic)：\n内存大小=元素大小x切片容量\n当内存分配完成，会返回底层数组的引用，并且和长度，容量合并成SliceHeader的结构体\n切片的底层数据结构如下：\n1 2 3 4 5 type SliceHeader struct { Data uintptr // 存储底层数组 Len int // 切片长度 Cap int // 切片分配的空间大小，小于Cap可以直接追加元素。 } 可以发现切片和数组主要不同在于cap字段。\n切片实际上是在数组的基础上加了一层抽象层，切片实际上是底层数组的一个引用，再加上长度和容量，当我们在运行时修改切片的长度和容量时，底层的数组可能会发生变化，而在上层引用看来切片并没有发生变化。\n切片和数组还有一点不同在于：切片只是在编译期间确定元素类型，而数组的编译期间就已经确定好了类型和长度。\n# 切片的访问 切片通过下标去访问元素：\n1 a := arr[3] //对切片的索引操作实际上会转化为地址的读取 在访问时，Go会进行边界检查,如果超出则会panic。\n切片可以获取长度和容量：\n1 2 3 arr := make([]int,10,20) l := len(arr) c := cap(arr) # 切片追加和扩容 在Go中使用append关键字对切片进行扩容, 扩容后会产生一个新的slice结构体，如果赋值回去原变量就相当于对原变量进行了扩容。\n1 2 arr := make([]int,3, 5) arr = append(arr, []int{1, 2}...) 当切片追加元素时，会根据：\n追加后切片长度小于等于容量\n追加后切片长度大于容量\n以及根据返回值是否覆盖原切片进行不同的流程\n如果触发了第二种情况，即容量不足的情况，Go会对切片进行扩容，扩容其实是为切片分配新的内存空间并拷贝原切片中元素的过程。\n在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：\nGo 1.18之前:\n如果期望容量大于当前容量的两倍就会使用期望容量； 如果当前切片的长度小于 1024 就会将容量翻倍； 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量； Go 1.18之后: 切片扩容不再以1024为临界点，而是设定了一个值为256的threshold。在计算完容量之后，会根据容量和元素大小相乘，如果新的切片发生了内存溢出或者请求内存大于上限则会直接panic。 如果期望容量大于当前容量的两倍就会使用期望容量； 当原切片容量 \u0026lt; threshold 的时候，新切片容量变成原来的 2 倍； 当原切片容量 \u0026gt; threshold 的时候，进入一个循环，每次容量增加(旧容量+threshold*3) / 4； # 切片拷贝 在Go中使用copy关键字进行切片的复制，实际上底层使用的是对内存的复制。\nGo对切片仅支持append和copy两种操作，需要注意的是在大切片中进行这两种操作会比较消耗资源。\n# 案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func func1(a []int) { b := make([][]int, 0) for i := 0; i \u0026lt; 10; i++ { t := append(a, i) b = append(b, t) } } // 需要理解到append的底层实现： 1. 判断原切片是否要扩容 2. 如果要扩容，先new一个新的数组，再copy值到新的数组；如果不需要扩容。直接追加元素 3. append操作实际上会生成一个slice结构体，如果赋值回去，原始切片会增加len；如果不赋值回去，则len不变。 func func2() { a := [...]int{0, 1, 2, 3} x := a[:1] // { pointer:-\u0026gt;a len:1 cap: 4} y := a[2:] x = append(x, y...) x = append(x, y...) fmt.Println(a, x) } //需要理解到[:]运算的本质 //实际上是创建一个切片的引用，底层数组还是指向原来切片，但len和cap发生变化。具体看是如何切割。 ","date":"2024-03-29T16:40:30+08:00","permalink":"https://bitfrost7.github.io/p/golang/slice/","title":"Golang学习-数组和切片"},{"content":" # 关键字 Go共有25个保留关键字：\n# 包管理（2个）： # import 用于导入包，这样就可以使用包中被导出的标识符。导入格式如下：\n1 2 3 4 import \u0026#34;fmt\u0026#34; //直接import import f \u0026#34;fmt\u0026#34; //添加包别名 import . \u0026#34;fmt\u0026#34; //代表导入包，使用时不用加包名 import _ \u0026#34;fmt\u0026#34; //不使用包中的标识符，只需要包的副作用（init函数，包级变量...） # package 用于声明包的名称，需放在go文件所有代码的最前面。一个包由一个或多个go源文件组成，需放在同一个目录下，且同一个目录下的这些go文件的package的名字只能有一个，且不能为\u0026quot;_\u0026quot;。 package \u0026lt;packagename\u0026gt;\n# 程序实体声明与定义（8个）： # chan 用于声明channel（信道）。信道提供一种机制使两个并发执行的函数实现同步，并通过传递具体元素类型的值来通信。\n1 2 3 chan T // 可以被用来发送和接收类型T的值 chan\u0026lt;- T // 只能被用来发送浮点数 \u0026lt;-chan T // 只能被用来接收整数 # const 用于定义常量，一旦创建，不可赋值修改\n# func func 用于定义函数。Go函数支持可变参数且返回值支持多个，但不支持默认参数。如果函数存在多个返回值形参则需要使用小括号括起来，定义格式如下：\n1 2 3 func funcName(){} //无参无返回值 func funcName(t T) T {} //有参有返回值 func funcName(t T, list ...T) (T1,T1) {} //有变参有多个返回值 # interface interface 用于定义接口。一个接口是一个方法集，如果一个类型实现了一个接口中的所有方法集，那么说明该类型实现此接口。接口类型变量可以存储任何实现了该接口的类型的值。特别的，interface{}表示空接口类型，默认地，所有类型均实现了空接口，所以interface{}可以接收任意类型值。\n# map map 用于声明映射变量。映射属容器类类型，是一个同种类型元素的无序组，通过唯一的键可以获取对应的值。可以使用 make 创建 map 变量，在定义 map 时可以省略容量，超出容量时会自动扩容，但尽量提供一个合理的初始值。未初始化的值为 nil。\n# struct struct 用于定义结构体。结构体属容器类型，是多个相同或不同类型值的集合 。一个结构体的零值是类型集合中所有类型的零值。\n# type type 用于定义类型，比如定义 struct、interface、func 与等价类型。\n# var var 用于申明函数级变量和包级变量。\n# 程序流程控制（15个）： # 循环 for 是 Go 中唯一用于循环结构的关键词, 有三种使用方式：1. 单条件 2. 循环变量 3 range\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // for 单条件用法 相当于while i := 0 for i \u0026lt; 10 { fmt.Println(i) i++ } // for 循环变量 for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } // for range 用法 s := []int{1, 2, 3} for i, v := range s { fmt.Println(i, v) } break continue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // break 跳出本次循环 for i := 0; i \u0026lt; 10; i++ { if i == 5 { break } fmt.Println(i) } // continue 跳过本次循环 for i := 0; i \u0026lt; 10; i++ { if i == 5 { continue } fmt.Println(i) } # 条件语句 if else else if 1 2 3 4 5 6 7 if i == 1 { fmt.Println(\u0026#34;i == 1\u0026#34;) } else if i == 2 { fmt.Println(\u0026#34;i == 2\u0026#34;) } else { fmt.Println(\u0026#34;i != 1 \u0026amp;\u0026amp; i != 2\u0026#34;) } switch default case\n1 2 3 4 5 6 7 8 switch i { case 1: fmt.Println(\u0026#34;i == 1\u0026#34;) case 2: fmt.Println(\u0026#34;i == 2\u0026#34;) default: fmt.Println(\u0026#34;i != 1 \u0026amp;\u0026amp; i != 2\u0026#34;) } # 跳转控制 return Go中一个函数可以有一个或者多个返回值，返回值通过return指定。\nreturn关键字中指定了参数时，返回值可以不用名称。如果return省略参数，则返回值部分必须带名称，当返回值带有名称时，必须使用()包起来 在一个函数块里，任何在return之后的代码都不会执行 defer goto # 并发控制 go select ","date":"2024-03-29T15:54:28+08:00","permalink":"https://bitfrost7.github.io/p/golang/","title":"Golang学习-关键字"}]