[{"content":" # dpdk开发 dpdk是一个提供了一个高性能网络框架，开发者可以在此基础上构建自己的网络应用程序，同时拥有接近硬件满速的性能。\ndpdk框架主要组件有：\n环境适配层 EAL(Environment Abstraction Layer)\n该组件通过提供了通用接口提供一些核心服务：\n1. DPDK的加载和启动\n2. 多线程和多进程执行方式\n3. CPU亲和性设置\n4. 系统内存分配和释放\n5. 原子操作\n6. 定时器\n7. PCI总线访问 8. \u0026hellip;\u0026hellip; 环形缓冲区(rte_ring) 该组件提供了一个无锁的环形队列数据结构，支持多生产者，多消费者。ring主要用于不同核之间或是逻辑核上处理单元之间的通信。 内存池管理（rte_mempool） 该组件主要职责就是在内存中分配指定数目对象的POOL。每个POOL以名称来唯一标识，并且使用一个ring来存储空闲的对象节点。 网络报文缓冲区(rte_mbuf) 报文缓存组件提供了创建、释放报文缓存的能力，DPDK应用程序中使用这些报文缓存来存储消息。 定时器(rte_timer) 该组件提供了定时服务，为函数异步执行提供支持，并且能在每个核上根据需要初始化。 除此之外，dpdk还提供了哈希（hash），最长前缀匹配的（lpm）算法库，以及ip协议相关的网络库等。 所有的dpdk api都能在官方文档中找到，多熟悉即可。\n# HelloWorld 以下是官方自带的helloworld代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/queue.h\u0026gt; #include \u0026lt;rte_memory.h\u0026gt; #include \u0026lt;rte_launch.h\u0026gt; #include \u0026lt;rte_eal.h\u0026gt; #include \u0026lt;rte_per_lcore.h\u0026gt; #include \u0026lt;rte_lcore.h\u0026gt; #include \u0026lt;rte_debug.h\u0026gt; static int lcore_hello(__attribute__((unused)) void *arg) { unsigned lcore_id; lcore_id = rte_lcore_id(); printf(\u0026#34;hello from core %u\\n\u0026#34;, lcore_id); return 0; } int main(int argc, char **argv) { int ret; unsigned lcore_id; // 1. 初始化环境抽象层（EAL） ret = rte_eal_init(argc, argv); if (ret \u0026lt; 0) rte_panic(\u0026#34;Cannot init EAL\\n\u0026#34;); /* call lcore_hello() on every slave lcore */ // 2. 在每个可用的lcore上调用lcore_hello RTE_LCORE_FOREACH_WORKER(lcore_id) { rte_eal_remote_launch(lcore_hello, NULL, lcore_id); } /* call it on master lcore too */ lcore_hello(NULL); rte_eal_mp_wait_lcore(); return 0; } 代码中关键在于：\nrte_eal_init(); 这个函数初始化dpdk EAL环境抽象层，开发必调函数。 RTE_LCORE_FOREACH_SLAVE(); 实际上是一个for循环的宏，遍历所有的可用slave核。 rte_eal_remote_launch(); 这个函数实际上就是让指定的slave核去执行函数，有些类似Golang中的go关键字。 rte_eal_mp_wait_lcore(); 这个函数实际上就是等待所有核上的任务执行完成。类似go中的waitgroup。 整体代码执行的话，使用gcc 手动链接比较麻烦，直接使用官方给的示例MakeFile即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # SPDX-License-Identifier: BSD-3-Clause # Copyright(c) 2010-2014 Intel Corporation # binary name APP = helloworld # all source are stored in SRCS-y SRCS-y := main.c PKGCONF ?= pkg-config # Build using pkg-config variables if possible ifneq ($(shell $(PKGCONF) --exists libdpdk \u0026amp;\u0026amp; echo 0),0) $(error \u0026#34;no installation of DPDK found\u0026#34;) endif all: shared .PHONY: shared static shared: build/$(APP)-shared ln -sf $(APP)-shared build/$(APP) static: build/$(APP)-static ln -sf $(APP)-static build/$(APP) PC_FILE := $(shell $(PKGCONF) --path libdpdk 2\u0026gt;/dev/null) CFLAGS += -O3 $(shell $(PKGCONF) --cflags libdpdk) LDFLAGS_SHARED = $(shell $(PKGCONF) --libs libdpdk) LDFLAGS_STATIC = $(shell $(PKGCONF) --static --libs libdpdk) ifeq ($(MAKECMDGOALS),static) # check for broken pkg-config ifeq ($(shell echo $(LDFLAGS_STATIC) | grep \u0026#39;whole-archive.*l:lib.*no-whole-archive\u0026#39;),) $(warning \u0026#34;pkg-config output list does not contain drivers between \u0026#39;whole-archive\u0026#39;/\u0026#39;no-whole-archive\u0026#39; flags.\u0026#34;) $(error \u0026#34;Cannot generate statically-linked binaries with this version of pkg-config\u0026#34;) endif endif CFLAGS += -DALLOW_EXPERIMENTAL_API build/$(APP)-shared: $(SRCS-y) Makefile $(PC_FILE) | build $(CC) $(CFLAGS) $(SRCS-y) -o $@ $(LDFLAGS) $(LDFLAGS_SHARED) build/$(APP)-static: $(SRCS-y) Makefile $(PC_FILE) | build $(CC) $(CFLAGS) $(SRCS-y) -o $@ $(LDFLAGS) $(LDFLAGS_STATIC) build: @mkdir -p $@ .PHONY: clean clean: rm -f build/$(APP) build/$(APP)-static build/$(APP)-shared test -d build \u0026amp;\u0026amp; rmdir -p build || true # 开发环境搭建 vscode + 远程开发remote-ssh插件\n","date":"2024-04-22T20:38:14+08:00","permalink":"https://bitfrost7.github.io/p/network/dpdk/02/","title":"dpdk学习02-运行helloworld"},{"content":" # 什么是dpdk？ dpdk是intel开源的一个网络加速工具包，目的是在IA平台上解决高性能网络数据包处理的问题。\n传统网络包处理的过程是：\n网卡收到数据包 网卡将帧DMA到内存 网卡发送硬中断 cpu响应中断，调用对应函数进行收包 将ring buffer保存到skb 内核协议栈处理帧 用户进程处理报文 因为传统网络包处理是中断驱动的，所以在大量网络请求下会出现irq风暴，降低处理性能。除此之外还涉及到多次用户态和内核态数据拷贝，降低性能。当时流行的做法是通过硬件来加速网络包处理，但是dpdk的产生证明了通用化硬件在软件极致优化的情况下也能做到达到io的极限。 基于IA处理器的DPDK技术，很好地解决高性能数据包处理的问题，这些技术包括：\n通过轮询来处理数据包，避免中断上下文切换的开销 使用用户态驱动，避免内核态到用户态不必要的内存拷贝和系统调用 设置cpu亲和性与独占，避免线程在不同核心间频繁切换; 限制某些核心不参与Linux系统调试, 可使线程独占该核心 利用大页内存降低TLB miss # dpdk安装 环境：Mac m1，Vmware Fusion 虚拟机，Ubuntu 20.04\n版本：dpdk 22.11.4\n因为ubuntu已经有了dpdk的二进制源，直接安装即可，如果需要二进制安装，可参考官方文档：\n1 apt install -yq dpdk dpdk-dev dpdk-doc gcc g++ # 配置环境 dpdk环境最好配置2张网卡，一个选择桥接，用来配置dpdk开发；一个选择NAT，用来和宿主机连接。cpu选择4核，内存选择8G，按宿主机资源即可。 配置dpdk环境需要2步：\n将网卡和dpdk绑定 设置内存大页 dpdk安装时已经自带了工具，可以很方便的配置：\ndpdk-devbind.py dpdk-hugepages.py 以下给出自己写的配置脚本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 root@ubuntu:~# cat scripts/dpdk-run.sh #!/bin/bash # var down_nics=() choice=\u0026#34;\u0026#34; selected_nics=() # 检查并输出DOWN状态的网络接口 function find_down_nics { ip a | grep \u0026#39;ens.*DOWN\u0026#39; | awk -F: \u0026#39;{print $2}\u0026#39; | tr -d \u0026#39; \u0026#39; } down_nics=($(find_down_nics)) # 检查是否有DOWN的接口 if [ ${#down_nics[@]} -eq 0 ]; then echo \u0026#34;没有找到DOWN状态的网络接口。\u0026#34; exit 0 fi # 打印选项 echo \u0026#34;请选择DOWN的网络接口：\u0026#34; for ((i=0; i\u0026lt;${#down_nics[@]}; i++)); do echo \u0026#34;$((i+1)). ${down_nics[i]}\u0026#34; done echo \u0026#34;$(( ${#down_nics[@]} + 1 )). all\u0026#34; # 读取用户选择 read -p \u0026#34;请输入选项编号： \u0026#34; choice if [ \u0026#34;$choice\u0026#34; == \u0026#34;$(( ${#down_nics[@]} + 1 ))\u0026#34; ]; then echo \u0026#34;您选择了所有DOWN的网络接口。\u0026#34; selected_nics=(\u0026#34;${down_nics[@]}\u0026#34;) else if [[ \u0026#34;$choice\u0026#34; =~ ^[0-9]+$ ]] \u0026amp;\u0026amp; [ \u0026#34;$choice\u0026#34; -le \u0026#34;${#down_nics[@]}\u0026#34; ]; then echo \u0026#34;您选择了接口：${down_nics[$((choice-1))]}\u0026#34; selected_nics=(\u0026#34;${down_nics[$((choice-1))]}\u0026#34;) else echo \u0026#34;无效的选择。\u0026#34; exit 1 fi fi # log选定的接口信息（包括IP地址） function log_selected_nics { # 确保bind.log存在 \u0026gt; bind.log for nic in \u0026#34;${selected_nics[@]}\u0026#34;; do # 尝试获取MAC地址 mac_address=$(ip link show \u0026#34;$nic\u0026#34; | awk \u0026#39;/link/ {print $2}\u0026#39;) if [ -z \u0026#34;$mac_address\u0026#34; ]; then mac_address=\u0026#34;无法获取\u0026#34; fi # 尝试获取IPv4地址 ip_address=$(ip addr show \u0026#34;$nic\u0026#34; | grep -oP \u0026#39;(?\u0026lt;=inet\\s)\\d+(\\.\\d+){3}/\\d+\u0026#39;) if [ -z \u0026#34;$ip_address\u0026#34; ]; then ip_address=\u0026#34;未分配\u0026#34; fi # 将接口名、MAC地址和IP地址写入文件 echo \u0026#34;绑定接口名称: $nic, MAC地址: $mac_address, IP地址: $ip_address\u0026#34; echo \u0026#34;绑定接口名称: $nic, MAC地址: $mac_address, IP地址: $ip_address\u0026#34; \u0026gt;\u0026gt; bind.log done } log_selected_nics # 将选定的网络接口绑定到dpdk function bind_dpdk_nics { for nic in \u0026#34;${selected_nics[@]}\u0026#34;; do # 检查接口是否存在并尝试绑定 if ip link show \u0026#34;$nic\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;正在绑定接口 $nic 到 vfio-pci...\u0026#34; sudo dpdk-devbind.py --bind=vfio-pci \u0026#34;$nic\u0026#34; if [ $? -eq 0 ]; then echo \u0026#34;接口 $nic 绑定成功。\u0026#34; else echo \u0026#34;绑定接口 $nic 失败，请检查错误。\u0026#34; fi else echo \u0026#34;接口 $nic 不存在，跳过绑定。\u0026#34; fi done } # 执行绑定操作 if [ ${#selected_nics[@]} -gt 0 ]; then bind_dpdk_nics else echo \u0026#34;没有接口被选中进行绑定。\u0026#34; exit 0 fi # 配置大页 function setup_huge_pages { # 示例命令配置2GB的1G大页 sudo dpdk-hugepages.py -p 1G --setup 2G if [ $? -eq 0 ]; then echo \u0026#34;大页配置成功。\u0026#34; else echo \u0026#34;配置大页失败，请检查错误。\u0026#34; fi } # 在执行完网络接口绑定之后，配置大页 echo \u0026#34;开始配置大页...\u0026#34; setup_huge_pages printf \u0026#34;dpdk 配置完成\\n\u0026#34; exit 0 # 第一个测试程序 测试程序使用dpdk官方提供的testpmd，测试dpdk网卡绑定 。\n因为网卡绑定到dpdk后无法查看ip和mac，所以绑定前需要保留这些信息，如果是运行脚本搭建，相关信息就在bind.log里。\n测试环境： 两台虚拟机，要求都已经安装了dpdk的环境。\n# 安装pktgen 1 2 3 4 5 6 7 git clone git://dpdk.org/apps/pktgen-dpdk cd pktgen-dpdk/ meson build cd build ninja # app/pktgen 编译出的程序 mv app/pktgen /usr/local/bin # 开始测试 node1 node2 mac信息\n1 2 3 4 5 6 node1 绑定接口名称: ens161, MAC地址: 00:0c:29:a5:21:1e, IP地址: 未分配 绑定接口名称: ens256, MAC地址: 00:0c:29:a5:21:14, IP地址: 未分配 node2 绑定接口名称: ens161, MAC地址: 00:0c:29:57:f0:2f, IP地址: 未分配 绑定接口名称: ens256, MAC地址: 00:0c:29:57:f0:25, IP地址: 未分配 在node1 上运行testpmd： 1 dpdk-testpmd -l 0-1 -n 1 -- -i 将网卡设为只读模式、非混杂模式(这样就只收pktgen发来的包)后开始收包 1 2 3 4 set fwd rxonly set promisc all off show port stats all start 在node2 运行pktgen 进行发包 1 pktgen -l 0-1 -n 3 -- -P -m \u0026#34;[1].0\u0026#34; 设置目的mac，发送100个包 1 2 3 set 0 dst mac 00:0c:29:a5:21:1e set 0 count 100 start 0 在node1上执行 show port stats all,此时可以发现其中一张网卡多了6400，pktgen发包默认大小64字节。 执行quit退出 测试符合预期，环境搭建完成。\n","date":"2024-04-22T19:16:59+08:00","permalink":"https://bitfrost7.github.io/p/network/dpdk/01/","title":"dpdk学习01—环境搭建"},{"content":" # DNS协议 # 什么是DNS协议？ # 域名体系 域名层级 域名服务器划分 # DNS解析流程 # DNS报文格式 # 基于DNS的网络攻击 DNS劫持 DNS污染 # HTTPDNS ","date":"2024-04-18T16:45:14+08:00","permalink":"https://bitfrost7.github.io/p/network/dns/","title":"计算机网络-DNS协议"},{"content":" # HTTP协议 # 什么是HTTP？ # 持续连接 # 非持续连接 # HTTP报文格式 # 请求报文 请求行 请求头 # 响应报文 状态行和状态码 首部行 # HTTP发展 # HTTPS加密 # Cookie和Session # WEB缓存代理和HTTP网关 # 基于HTTP补充的协议 # HTTP网络攻击 ","date":"2024-04-18T14:50:50+08:00","permalink":"https://bitfrost7.github.io/p/network/http/","title":"计算机网络-HTTP协议"},{"content":" # 计算机网络 计算机网络（Computer Network）是指将多台计算机和其他网络设备连接起来，使它们能够相互通信和共享资源的系统。\n# 什么是Internet？ 因特网是一个世界范围的计算机网络，它是一个互联了遍及全世界数十亿计算设备的网络，可以说是世界上最大的一个计算机网络。\n端系统\n通常将和Internet相连的这些主机，叫做端系统（End System），可能是一台PC，也可能是一部手机，也可能是一台服务器。端系统分为两类：客户 (client)和服务器(server)。\n客户端一般是使用互联网服务的用户，而服务器通常是提供服务的机器，通常性能更为强大，部署在数据中心IDC（data center）， 数据中心往往有着更为复杂的网络架构。 路由器\n路由器（Routers）是Internet的核心组件，负责在网络间转发数据包。通俗的来讲，路由器就像高速公路上的路牌，指示了车辆该往哪个方向走。 路由器依据数据包的IP地址和路由表决定数据包的最佳路径，并在不同网络之间执行数据包交换。 交换机\n交换机（Switch）是计算机网络中用于连接多台计算机和其他网络设备的网络设备，负责在局域网（LAN）中实现数据包的转发和交换，从而实现设备之间的通信。 可以将交换机理解为就像环线路口连接了多条道路，任一驶入路口的车辆能根据自己的目的地选择出口，交换机也连接了多台计算机和网络设备，可以选择性地将数据包转发到特定的端口完成通信。 ISP\nISP指的是互联网服务提供商（Internet Service Provider），是指向个人、家庭、企业等提供互联网接入服务的公司或组织。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。 ISP分为地区ISP，在某一个城市提供接入服务；国家级ISP，比如中国联通；全球ISP，在全球范围内提供互联网接入服务的大型ISP，例如AT\u0026amp;T。 无论那种ISP都是一个独立的网络，较高级ISP都是通过高速光纤链路互联起来。 协议\n想象一下，当你和朋友聊天时，你们会遵循一定的语言规则（比如英语或中文的语法规则），确定谁先说话、说什么内容、怎样说才能确保对方理解。在网络世界中，设备之间的沟通同样需要这样的规则。 所谓协议，其实就是一系列规定好的语法，语义，时序，按照这样的规则，让通信双方都能理解。网络协议 (protocol) 定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。 因特网标准和RFC文档 对于互联网通信，一个规范且通用的协议十分重要，因特网工程任务组(Internet Engineering Task Force, IETF )制定了一系列通信标准，并且这个标准也开放在互联网上，被称为 请求评论（Request For Comment, RFC）。 例如RFC 894 定义了如何在以太网帧格式上封装IP数据报。 # Internet是怎么工作的？ # 接入网 # 核心网 分组交换 电路交换 # 分层网络体系 # 应用模型 应用层 运输层 网络层 链路层 物理层 # OSI模型 # 封装，分组，卸载，组装 # Internet发展和前景 # 历史 # 网络攻击 # 前景 ","date":"2024-04-18T10:34:34+08:00","permalink":"https://bitfrost7.github.io/p/network/introduction/","title":"计算机网络-简介"},{"content":" # Zap介绍 zap 是 uber 开源的一个高性能，结构化，分级记录的日志记录包。\n# 特性 高性能：zap 对日志输出进行了多项优化以提高它的性能 日志分级：有 Debug，Info，Warn，Error，DPanic，Panic，Fatal 等 日志记录结构化：日志内容记录是结构化的，比如 json 格式输出 自定义格式：用户可以自定义输出的日志格式 自定义公共字段：用户可以自定义公共字段，大家输出的日志内容就共同拥有了这些字段 调试：可以打印文件名、函数名、行号、日志时间等，便于调试程序 自定义调用栈级别：可以根据日志级别输出它的调用栈信息 Namespace：日志命名空间。定义命名空间后，所有日志内容就在这个命名空间下。命名空间相当于一个文件夹 支持 hook 操作 # 安装 1 go get -u go.uber.org/zap ","date":"2024-04-15T13:57:43+08:00","permalink":"https://bitfrost7.github.io/p/golang/libs/zap/","title":"Golang学习-zap日志库"},{"content":" # 上下文Context # 什么是context？ Go 1.7 版本引入了context.Context 接口，主要用于处理涉及多个 goroutine间的协作、取消信号传递、超时控制以及携带数据。\ncontext.Context 可以看作是一个封装了任务执行环境的对象，可以理解为协程间的执行上下文。它允许在整个协程树中传播这些上下文，并且提供了一种并发安全的方式来通知所有相关的goroutine 应该尽早结束其任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // context 接口定义 type Context interface { // Deadline()返回一个完成工作的截止时间，表示上下文应该被取消的时间。 // 如果 `ok==false` 表示没有设置截止时间。 Deadline() (deadline time.Time, ok bool) // Done()返回一个 Channel，这个 Channel 会在当前工作完成时被关闭，表示上下文应该被取消。 // 如果无法取消此上下文，则 Done 可能返回 nil。多次调用 Done 方法会返回同一个 Channel。 Done() \u0026lt;-chan struct{} // Err()返回Context结束的原因，它只会在Done方法对应的Channel关闭时返回非空值。 // 如果Context被取消，会返回context.Canceled错误； // 如果Context超时，会返回context.DeadlineExceeded错误。 Err() error // Value()从Context中获取键对应的值。 // 如果未设置key对应的值则返回nil。以相同key多次调用会返回相同的结果。 Value(key interface{}) interface{} } # context使用 context的最大用处就是用做协程间信号同步。\n以常见的api服务为例，每一个请求都是由一个goroutine处理，而每个处理协程可能都会启动新的子协程来辅助处理任务，这就构成一个goroutine树。而 context 的作用就是在不同 goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。 在具体使用的时候，context包提供了四种With函数来派生出我们需要的上下文：\n1 2 3 4 5 6 7 8 9 10 11 // WithCancel 返回一个带有终止控制的context func WithCancel(parent Context) (ctx Context, cancel CancelFunc) // WithDeadline 返回一个带有定时器的context，也带有终止控制 func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) // WithTimeout 返回一个带有超时控制的context，也带有终止控制 func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) // WithValue 返回一个带有参数的context func WithValue(parent Context, key, val interface{}) Context 通常我们先创建一个空context，再由此派生出我们需要的context，就创建出来了一颗context树。 在context的派生关系中：\n当父context取消时，子context也都会被取消； 当父context设置参数时，子context也能读取到这个参数，但key只能被设置一次，不能被修改。 # 默认上下文 context包主要提供了两种创建默认context的方式：\n1 2 context.Backgroud() context.TODO() 这两个函数其实只是互为别名，没有差别，官方给的定义是：\ncontext.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来； context.TODO 应该只在不确定应该使用哪种上下文时使用； 在大多数情况下，我们都使用context.Background作为起始的上下文向下传递。 从源码中我们可以看到，这两个context都是返回了一个emptyCtx的指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type emptyCtx struct{} func (emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (emptyCtx) Done() \u0026lt;-chan struct{} { return nil } func (emptyCtx) Err() error { return nil } func (emptyCtx) Value(key any) any { return nil } 实际上emptyCtx实现的都是空方法，没有任何功能。\n# 取消信号 WithCancel方法可以从一个context中衍生出一个新的子上下文，并且提供一个取消函数，当这个取消函数被调用时，当前上下文以及它的子上下文都会被取消，所有的 goroutine 都会同步收到这一取消信号。\n1 2 3 4 5 6 7 8 9 10 11 12 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := withCancel(parent) return c, func() { c.cancel(true, Canceled, nil) } } func withCancel(parent Context) *cancelCtx { if parent == nil { panic(\u0026#34;cannot create context from nil parent\u0026#34;) } c := \u0026amp;cancelCtx{} c.propagateCancel(parent, c) //构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消 return c } 当cancelFunc被调用时：\n会先关闭Done，同步关闭信号 调用持有的所有子context的cancelFunc 从父context移除自己，删掉父context持有的自己的cancelFunc 以下是部分源码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func (c *cancelCtx) cancel(removeFromParent bool, err, cause error) { ... // close done channel d, _ := c.done.Load().(chan struct{}) if d == nil { c.done.Store(closedchan) } else { close(d) } // 关闭所有子context for child := range c.children { // NOTE: acquiring the child\u0026#39;s lock while holding parent\u0026#39;s lock. child.cancel(false, err, cause) } // 从父context移除自己 if removeFromParent { removeChild(c.Context, c) } } 除了 context.WithCancel 之外，context 包中的另外两个函数 WithDeadline 和 WithTimeout 也都能创建可以被取消的计时器上下文。\n1 2 3 4 // WithTimeout函数底层也是通过WithDeadline实现，只是deadline设置为now+timeout。 func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } WithDeadline 的主要逻辑是：\n判断了父上下文的截止日期与当前日期 和父上下文进行关联 通过 time.AfterFunc 创建定时器 当时间超过了截止日期后会调用 cancel 同步取消信号 # 传值上下文 context 包提供了一个WithValue方法，能从父上下文中创建一个子上下文，并且能够存储一个kv对。返回一个valueCtx结构体：\n1 2 3 4 type valueCtx struct { Context key, val any } valueCtx结构体会将除了 Value 之外的 Err、Deadline 等方法代理到父上下文中，它只会响应 Value 方法。\n当通过Value方法获取某个key时，如果和自己存储的kv对不存在，则会到父上下文去寻找。\n# 总结 自从go1.7引入了context包，context几乎成了协程间之间同步取消信号和上下文信息传递的标准做法，实践上，经常应用于像TraceId，公共参数，鉴权校验，接口超时等场景，都会使用context作为媒介。\n","date":"2024-04-02T17:32:17+08:00","permalink":"https://bitfrost7.github.io/p/golang/context/","title":"Golang学习-上下文context"},{"content":" # 介绍 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。 单例模式有两个特点：\n一个类只有一个实例 该实例只有一个全局访问节点 # 实现 单例模式的实现需要三个必要的条件：\n单例类的构造函数必须是私有的，这样才能将类的创建权控制在类的内部，从而使得类的外部不能创建类的实例。 单例类通过一个私有的静态变量来存储其唯一实例。 单例类通过提供一个公开的静态方法，使得外部使用者可以访问类的唯一实例。 单例的实现一共有五种方式： # 饿汉式（静态初始化） 天生线程安全，效率高 如果实例没有被使用，会造成内存浪费，并且生命周期固定，比方说要求根据配置文件变化，不能重新初始化或替换实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package singleton type Singleton struct { } var instance *Singleton func init() { instance = \u0026amp;Singleton{} } func GetInstance() *Singleton { return instance } # 懒汉式 (用时初始化) 线程不安全 1 2 3 4 5 6 7 8 9 10 11 12 13 package singleton type Singleton struct { } var instance *Singleton func GetInstance() *Singleton { if instance == nil { instance = \u0026amp;Singleton{} } return instance } # 双重检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package singleton import \u0026#34;sync\u0026#34; type Singleton struct { } var ( instance *Singleton once sync.Once ) func GetInstance() *Singleton { once.Do(func() { instance = \u0026amp;Singleton{} }) return instance } ","date":"2024-03-29T22:24:18+08:00","permalink":"https://bitfrost7.github.io/p/design-patterns/singleton/","title":"设计模式-单例"},{"content":" # 标准库容器 Go语言中有一个 container 包，提供了三种常用的数据结构：list双向链表，heap堆，ring环\n# List 链表是一种常见的数据结构，它由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表的优点是在插入和删除操作时非常高效 O(1)，而在访问时效率较低 O(n)。链表有单向链表、双向链表和循环链表等多种类型，链表还有许多变种，如哈希链表、跳表等。 在Go中cotainer/list 实现了双向链表。 数据结构如下：\n1 2 3 4 5 6 7 8 9 10 type Element struct { next, prev *Element list *List Value any } type List struct { root Element // sentinel list element, only \u0026amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element } 链表头尾节点使用了哨兵节点，方便删除和插入。\n# List常用api 名称 函数参数 作用 New 无 new一个list返回 Front 无 返回头节点 Back 无 返回尾节点 Remove element 移除节点 PushFront value any 头部添加元素 PushBack value any 尾部添加元素 InsertBefore value any , mark element 在mark后添加元素 MoveToFront e element 移动节点到头部 PushBackList other *list 将另一个列表添加进去 1 2 3 4 // 遍历一个链表 for e := a.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } # Heap Go语言container包中， heap 为所有实现了 heap.Interface 的类型提供了堆操作。\n堆，其实是一个优先级队列，这个队列里按照优先级排，优先级高的在堆顶，优先级低的在堆底。 一个堆是一个完全二叉树，树中不存在气泡，是连续存储的，所以可以直接由数组实现。\nGolang中的堆是最小堆，父节点的值总是小于子节点的值，所以root节点的值最小。\n# 接口定义 Go中要使用heap，必须实现heap.Interface:\n1 2 3 4 5 type Interface interface { sort.Interface Push(x any) // add x as element Len() Pop() any // remove and return element Len() - 1. } 除了实现pop和push之外 还需要实现sort接口。\n# 提供函数 heap接口提供了几个堆操作的函数：\nInit 用于在使用堆之前对堆进行初始化。 1 2 3 4 5 6 7 func Init(h Interface) { // heapify n := h.Len() for i := n/2 - 1; i \u0026gt;= 0; i-- { down(h, i, n) } } Pop/Push 用于弹出或者推入元素 1 2 3 4 5 6 7 8 9 10 11 12 13 // Push 函数将值为 x 的元素推入到堆里面，该函数的复杂度为 O(log(n)) 。 func Push(h Interface, x any) { h.Push(x) up(h, h.Len()-1) } // Pop 函数根据 Less 的结果， 从堆中移除并返回具有最小值的元素。 // 等同于执行 Remove(h, 0)，复杂度为 O(log(n))。（n 等于 h.Len() ）。 func Pop(h Interface) any { n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() } Remove 移除元素 1 2 3 4 5 6 7 8 9 10 func Remove(h Interface, i int) any { n := h.Len() - 1 if n != i { h.Swap(i, n) if !down(h, i, n) { up(h, i) } } return h.Pop() } Fix 有时候我们会修改i上的值，这时需要调用Fix来修复元素顺序。尽管可以先删除i的值，再push，但是直接修改加Fix的成本会小一些。 1 2 3 4 5 func Fix(h Interface, i int) { if !down(h, i, h.Len()) { up(h, i) } } heap包里还有几个关键函数:\nup 将所给索引的元素向上调整到其正确的位置，以满足堆的性质。 down 将所给索引 的元素向下调整至其子节点中合适的位置，保证堆的性质。并且返回是否下沉，即返回true表示发生了下沉，false表示未发生下沉。 # 使用heap实现一个优先级队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package main import ( \u0026#34;container/heap\u0026#34; \u0026#34;fmt\u0026#34;) // 定义一个实现了heap.Interface的结构体 type PriorityQueue struct { items PriorityQueueItems } type PriorityQueueItem struct { Value int // 具体的值 Priority int // 优先级，这里假设数值越大的优先级越高 index int // 用于heap.Interface所需的索引 } type PriorityQueueItems []PriorityQueueItem // 实现heap.Interface的三个方法 func (pq PriorityQueueItems) Len() int { return len(pq) } func (pq PriorityQueueItems) Less(i, j int) bool { return pq[i].Priority \u0026gt; pq[j].Priority } // 大顶堆 func (pq PriorityQueueItems) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pq *PriorityQueueItems) Push(x interface{}) { n := len(*pq) item := x.(PriorityQueueItem) item.index = n *pq = append(*pq, item) } func (pq *PriorityQueueItems) Pop() interface{} { old := *pq n := len(old) item := old[n-1] old[n-1] = PriorityQueueItem{} *pq = old[0 : n-1] return item } // 优先级队列对外提供的方法 func (pq *PriorityQueue) Push(value int, priority int) { item := PriorityQueueItem{ Value: value, Priority: priority, } heap.Push(\u0026amp;pq.items, item) } func (pq *PriorityQueue) Pop() (value int, ok bool) { if pq.items.Len() == 0 { return 0, false } item := heap.Pop(\u0026amp;pq.items).(PriorityQueueItem) return item.Value, true } func NewPriorityQueue() *PriorityQueue { return \u0026amp;PriorityQueue{items: make(PriorityQueueItems, 0)} } func main() { pq := NewPriorityQueue() pq.Push(3, 1) pq.Push(1, 3) pq.Push(2, 2) for pq.items.Len() \u0026gt; 0 { value, _ := pq.Pop() fmt.Println(value) // 输出顺序应为：3, 2, 1 } } # Ring 在 Go 语言的标准库中，container/ring 包提供了环形缓冲区（Ring Buffer）的实现，也称为循环队列。环形缓冲区是一种固定大小的缓冲区，其特点是当缓冲区满时，新的数据会覆盖最旧的数据，形成一个首尾相连的环状结构。这种数据结构常用于缓存最近使用的数据、限流等场景。\n# 提供函数 New() 创建一个新的环形缓冲区实例，具有给定的大小。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func New(n int) *Ring { if n \u0026lt;= 0 { return nil } r := new(Ring) p := r for i := 1; i \u0026lt; n; i++ { p.next = \u0026amp;Ring{prev: p} p = p.next } p.next = r r.prev = p return r } Link()和Unlink() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // LInk用于连接另一个`ring` func (r *Ring) Link(s *Ring) *Ring { n := r.Next() if s != nil { p := s.Prev() // Note: Cannot use multiple assignment because // evaluation order of LHS is not specified. r.next = s s.prev = r n.prev = p p.next = n } return n } // Unlink用于移除一个元素 func (r *Ring) Unlink(n int) *Ring { if n \u0026lt;= 0 { return nil } return r.Link(r.Move(n + 1)) } Prev() Next() Move() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Prev返回指向前一个元素的环形缓冲区节点 func (r *Ring) Next() *Ring { if r.next == nil { return r.init() } return r.next } // Next返回指向下一个元素的环形缓冲区节点 func (r *Ring) Prev() *Ring { if r.next == nil { return r.init() } return r.prev } // Move将环形缓冲区的指针移动n个位置，正数表示向前移动，负数表示向后移动 func (r *Ring) Move(n int) *Ring { if r.next == nil { return r.init() } switch { case n \u0026lt; 0: for ; n \u0026lt; 0; n++ { r = r.prev } case n \u0026gt; 0: for ; n \u0026gt; 0; n-- { r = r.next } } return r } Len Do 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Len 返回环形缓冲区中有效元素的数量。 func (r *Ring) Len() int { n := 0 if r != nil { n = 1 for p := r.Next(); p != r; p = p.next { n++ } } return n } // Do 对环形缓冲区中的每个元素执行给定的函数 func (r *Ring) Do(f func(any)) { if r != nil { f(r.Value) for p := r.Next(); p != r; p = p.next { f(p.Value) } } ","date":"2024-03-29T22:04:44+08:00","permalink":"https://bitfrost7.github.io/p/golang/container/","title":"Golang学习-container库"},{"content":" # 哈希表概念 哈希表是一种十分重要的数据结构，具有O(1)的读写速度，并且存储着键值对之间映射关系。\n哈希函数(hash)，也叫做散列函数，本质上是一种抽样函数，好比原来有一长串字符aabbccddeeff，抽样后成了abcdef，所以，哈希函数有个特点：输入范围必然小于输出范围。但在哈希表中，key值往往是无限的，通过哈希计算后必定会出现相同的值，被称为哈希冲突或者哈希碰撞。哈希冲突无法解决，比较实际的方式是通过让哈希函数的结果能够尽可能的均匀分布，但假设发生了哈希冲突，常用的解决方式有两种——开放寻址法和拉链法。\n# 开发寻址法 开放寻址法是一种解决哈希冲突的方法，这种方法的核心在于依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中，这种方式实现的哈希表底层是一个定长的数组，当我们往哈希表中写入一个数据时：\n根据唯一key计算哈希值\n通过哈希值计算出索引：inedx := hash(key)%len(array)\n索引处若为空直接插入，如果已经有值则找到往后第一个不为空的地方插入\n查找的逻辑相似，主要在于第3步，如果索引处没有找到相应的键值对，则往后遍历直到遍历完或者找到为止。\n开放寻址法的有好处是底层数据架构足够简单，缺点也很明显，当元素个数趋近于数组大小时，哈希表的效率会急速下降，一旦元素个数等于数组大小时，查找一个键值对的复杂度是O(n)，需要遍历整个数组。\n# 拉链法 拉链法是一种基于数组和链表的结构，数组元素是一个链表，形似拉链。\n当我们写入一个kv时：\n根据唯一key值计算hash值\n通过hash值的低B位 来计算放到那个桶(bucket)里\n如果桶中找到key相同的链表节点则更新该kv对，若非没有找到则在链表结尾追加该kv对\n查找的逻辑类似，于开放寻址法不同，拉链法即使存放元素个数和数组大小相同，查找和存取的效率远远好过开放寻址法。在开放寻址法中，有装载因子这一概念：\n装载因子:= 元素个数 / 桶数量\n拉链法的装载因子越大效率越低，大多数情况下装载因子不会超过1，如果装载因子过大，会触发桶的扩容，设计重新计算hash索引，但即便10的装载因子仍然比O(n)的效率要高。\n# Go中map实现 Go语言使用了两个主要结构表示哈希表，hmap和bmap，关于哈希表的结构在$GOROOT\\src\\runtime\\map.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type hmap struct { count int //代表哈希表中的元素个数 flags uint8 B uint8 //哈希表buckets的个数，因为buckets一般是2的倍数，所以B为2的对数 noverflow uint16 hash0 uint32 // hash seed buckets unsafe.Pointer //bucket数组的指针 oldbuckets unsafe.Pointer //哈希表在扩容之前保存之前buckets的指针 nevacuate uintptr extra *mapextra } type mapextra struct { overflow *[]*bmap oldoverflow *[]*bmap nextOverflow *bmap } hmap中存储元素的桶的结构是bmap，每一个bmap中存储着8个kv对，以及8个tophash，当单个桶已经装满时，就会存储到溢出桶overflow中去，当溢出桶也逐渐变多时，也会触发哈希表的扩容。\n1 2 3 4 5 6 7 type bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr } # 初始化 在Go中一般使用字面量来初始化哈希表：\n1 2 3 4 m := make(map[string]int, 3) m[\u0026#34;1\u0026#34;] = 2 m[\u0026#34;3\u0026#34;] = 4 m[\u0026#34;5\u0026#34;] = 6 Go初始化一个map的过程主要是以下步骤：\n计算哈希表所占用的内存大小是否溢出\n获取一个随机的哈希种子\n根据kv对的数量来计算桶的数量\n创建桶数组buckets\n创建溢出桶overflow ，此时会根据正常桶的数量来创建溢出桶： 当桶的个数小于2^4时，此时使用溢出桶的可能比较小，会省略创建溢出桶\n当桶的个数大于2^4时，则额外创建2^(B-4)个溢出桶\n溢出桶和正常桶的内存分布是连续的\n# 读写 哈希表的读主要分为直接获取和遍历：\n1 2 3 4 value := m[key] for k,v := range m{ //k,v } 哈希表的写操作分为：插入，修改和删除:\n1 2 3 m[newkey] = newvalue m[key] = value delete(m,key) # 访问 哈希表访问的时候有两种方式，一种是只返回value，还有一种是返回value和一个bool值,来表示哈希表中是否存在这个键值对。\n1 2 v := hashtable[k] v,ok := hashtable[k] 在根据key值查找哈希表时，会经过以下步骤：\n通过哈希表设置的哈希函数、种子获取当前键对应的哈希\n计算该键值对所在的桶序号和哈希高位的 8 位数字 计算桶序号：哈希值低B位，比如说B=5，取低5位00100，也就是第4个桶\n将哈希值高8位和Tophash对比，确定在bucket中那个槽位\n当发现桶中的 tophash 与传入键的 tophash 匹配之后，会通过指针和偏移量获取哈希中存储的键 keys[0]并与 key 比较，如果两者相同就会获取目标值的指针 values[0] 并返回\n当需要返回bool值的时候会根据键值对是否存在再返回，更推荐这种方式。\n当哈希表处于扩容状态时，如果哈希表的 oldbuckets 存在时，对哈希表的访问会先定位到旧桶并在该桶没有被分流时从中获取键值对。\n# 写入 哈希表在写入时，主要步骤：\n根据key计算hash，找到对应的桶；\n通过hash(key)和tophash进行比较，找到对应的槽位；\n遍历正常桶和溢出桶，如果存在，返回对应val内存地址；如果不存在，则会为新键值对规划存储的内存地址。如果当前桶已经满了，则会创建新的溢出桶来保存数据，同时增加hmap中的noverflow计数器\n# 扩容 在Go中往哈希表中插入数据时，当桶中的数据过多，原本O(1)的读写效率可能退化到O(n)，这时候就需要扩容，哈希表会在插入新元素的时候进行判断：\n装载因子大于6.5时, 装载因子：loadFactor := count / (2^B)，此时会进行翻倍扩容，扩容后newbuckets = 2^(B+1)\n溢出桶的个数过多时：\n当B小于15时，如果此时溢出桶overflow 的数量超过 2^B，也就是正常桶的数量\n当B大于15时，如果此时溢出桶overflow的数量超过了2^15\n此时会进行等量扩容，因为溢出桶过多说明此时哈希表中进行了大量的插入和删除操作，导致kv分散，降低了哈希表查找的效率。\nGo中哈希表的扩容不是一个原子过程，哈希表会创建一组新桶和溢出桶，再将当前桶挂到hmap中oldbuckets字段，此时并没有对数据进行拷贝，而是在传入数据时将旧桶中的数据进行分流到新桶中去，避免了一次拷贝带来的性能压力，被叫做渐进式扩容。\n哈希表扩容的详细流程：\n当哈希表判断需要进行扩容时，调用hashGrow函数，进入扩容状态，此时会创建新桶和溢出桶，并将当前桶挂到oldbuckets中\n当哈希表调用插入或者删除时，会判断当前哈希表处于扩容状态，并且调用growWork函数进行数据迁移\n在迁移过程中，会根据翻倍扩容还是等量扩容进入不同的迁移流程： 如果是等量扩容，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。\n如果是翻倍扩容，需要重新计算hash，再决定它落在那个桶中，这一阶段会涉及分流:\n举个例子：原始 B = 2，1号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 10 决定它们落在 2 号桶，现在 B 变成 3，所以 010，110 分别落入 2、6 号桶。\n因为迁移的过程并非原子，所以哈希表会在迁移过程中保留一个上下文结构runtime.evacDst，等量扩容为一个，翻倍扩容为两个。\n当哈希表完成扩容之后，会清空oldbuckets，以加速GC。\n# 删除 哈希表删除需要用到delete关键字，删除的逻辑和插入很类似，如果找不到删除的key值，或者map为空不会进行任何操作，当map处于扩容阶段，会进行桶中元素的分流，分流之后再完成键值对的删除。\n# 使用嵌套map 在Go中 可以通过类似于map[string]map[string]int这样的方式定义嵌套map，表示声明一个键为string，值为map[string]int的map。\n在Go中使用未初始化的map会panic，所以以下代码会运行报错：\n1 2 3 m := make(map[string]map[string]int) m[\u0026#34;aa\u0026#34;][\u0026#34;b\u0026#34;] = 1 panic: assignment to entry in nil map 正确使用应该先初始化内部map：\n1 2 3 4 m := make(map[string]map[string]int) m[\u0026#34;aa\u0026#34;] = make(map[string]int) m[\u0026#34;aa\u0026#34;][\u0026#34;bb\u0026#34;] = 1 fmt.Println(m) # 并发安全的map Go 语言原生 map 并不是线程安全的，对它进行并发读写操作的时候，需要加锁。\n在Go1.9引入了并发安全的map——sync.map。\n使用 sync.map 之后，对 map 的读写，不需要加锁。并且它通过空间换时间的方式，使用 read 和 dirty 两个 map 来进行读写分离，降低锁时间来提高效率。\n1 2 3 4 5 6 type Map struct { mu Mutex read atomic.Value // readOnly dirty map[interface{}]*entry misses int } # 使用sync.map # GC中的map ","date":"2024-03-29T21:33:25+08:00","permalink":"https://bitfrost7.github.io/p/golang/hashmap/","title":"Golang学习-哈希表"},{"content":" # 字符串基本使用 # 声明和初始化字符串 在Go中要声明一个字符串可以这样：\n1 2 3 var s string s := \u0026#34;hello world\u0026#34; s := \u0026#34;你好\u0026#34; //Go也支持中文字符串 # 格式化输出 在Go中格式化输出字符串主要使用fmt包中的Printf和Sprintf，例如：\n1 2 3 4 a := \u0026#34;世界\u0026#34; fmt.Printf(\u0026#34;hello,%s\u0026#34;, a) str := fmt.Sprintf(\u0026#34;hello,%s\u0026#34;, a) fmt.Println(str) 注意：Sprintf会返回格式化后的字符串，而Printf仅仅只能打印\n# 字符串编码 Go中字符串使用的是UTF-8编码的Unicode字符序列，需要注意的是在编写Go代码时，需要将编辑器保存设置为UTF-8格式，否则可能会出现编译错误。\n在Go中汉字通常占3个字节，而英文字母只需要1个。\n# 字符串相关函数 Go中字符串相关的函数都在strings包中\n前缀后缀 1 2 3 4 //判断字符串s前缀是否是prefix HasPrefix(s, prefix string) bool //判断字符串s后缀是否是suffix HasSuffix(s, suffix string) bool 是否包含 1 2 3 4 5 6 //字符串s是否包含子串substr Contains(s string, substr string) bool //字符串是否包含chars内任一字符 ContainsAny(s string, chars string) bool //字符串是否包含某一字符 ContainsRune(s string, r rune) bool 判断索引位置 1 2 3 4 //返回字符串s中第一个substr的位置，如果没有找到返回-1 Index(s, substr string) int //返回字符串s最后一个substr的位置，如果没有找到返回-1 LastIndex(s, substr string) int 字符串替换 1 2 3 4 5 6 7 8 //将字符串s的前n个字符串old替换为new，返回新字符串，如果n=-1则替换所有的new为old Replace(s, old, new string, n int) string //例子: s := \u0026#34;hello,world\u0026#34; new := strings.Replace(s, \u0026#34;l\u0026#34;, \u0026#34;j\u0026#34;, -1) //把s中的所有\u0026#39;l\u0026#39;替换为\u0026#39;j\u0026#39; fmt.Println(s, new) //输出: hello,world hejjo,worjd 字符串计数 1 2 //返回s中出现substr的次数，如果substr为空，则返回len(s)+1 Count(s, substr string) int 大小写转换 1 2 3 4 //将字符串s转换为小写字母返回 ToLower(s string) string //将字符串s转换为大写字母返回 ToUpper(s string) string 修剪字符串 1 2 3 4 5 6 7 8 //剔除掉字符串s前后的cutset Trim(s, cutset string) string //仅剔除字符串s开头的cutset TrimLeft(s, cutset string) string //仅剔除字符串s结尾的cutset TrimRight(s, cutset string) string //剔除字符串s开头结尾的空格 TrimSpace(s string) string 分割和拼接 1 2 3 4 5 6 //将字符串s以空白字符为分隔符切分成数组 Fields(s string) []string //将字符串s以sep为分隔符切分成数组 Split(s, sep string) []string //将字符串数组elems使用sep拼接 返回新字符串 Join(elems []string, sep string) string # 字符串底层原理 # 字符串数据结构 在Go中字符串的底层实际上是一个struct：\n1 2 3 4 type StringHeader struct { Data uintptr Len int } 字符串结构体有一个byte数组指针和一个代表长度的len。\nGo使用\u0026quot;\u0026quot;来声明单行字符串，```来声明多行字符串。\n1 2 3 s1 := \u0026#34;hello world!\u0026#34; s2 := `hello world!` 在Go中string类型是不可变的，在分配内存时会被分配到只读区域，同样在其他语言中字符串类型也是不可变的，这样做的原因是：\n安全：大部分密码都是以字符串形式存储，如果可以修改会造成安全漏洞\n性能：通常HashMap的key一般会是字符串，字符串不可变就能进行hashcode缓存避免重复计算\nGo中并没有字符串常量池这种设计，意味着每次创建相同的字符串会重复分配内存，在某些情况下可能会成为瓶颈，可以自己实现字符串常量池来避免。\n如果需要对字符串强行进行修改，如果字符串只包含ASCII码以内的字符，可以先转换为[]byte类型，在进行修改，再转换为字符串。但是这种方式并没有改变内存中的不可变区域，而是在新的内存区域。\n# 单引号和双引号的区别 在Go中单引号和双引号是由本质区别的，单引号 — rune类型，其实就相当于int32类型，占4个字节，在Unicode编码中最大4个字节就能表示一个字符。比方说：fmt.Println('a') 结果是97，是ASCII码表中的a的值。双引号—string类型，在Go中双引号表示字符串类型，Go 语言中字符串默认是 UTF-8 编码的 Unicode 字符序列，也就是byte数组\n# rune和string异同点 类型 rune（单引号） string（双引号） 底层类型 int32 byte数组 是否能互相转换 是 是 是否可变 不可变 不可变 ","date":"2024-03-29T18:36:49+08:00","permalink":"https://bitfrost7.github.io/p/golang/string/","title":"Golang学习-字符串"},{"content":" # Go中的数据类型介绍 在Go中数据类型分为3大类：基础类型，如int，float，bool这些基础类型。内置类型，比如slice，map，channel这些。派生类型，从基础类型或者内置类型组合自定义出来的类型，也可以看作Go中的\u0026quot;对象\u0026quot;。\n字长：计算机CPU总线的位宽，一般有32位和64位，限制了cpu一次能读取的数据\n字节：一位0或者1就是1bit，1byte = 8bit，1024 byte = 1kb， 1024 kb = 1 MB，1024 MB = 1GB # 数字类型 在Go中int 类型的大小是根据底层系统的字长决定，32位系统下是4字节，64位系统下是8字节。而固定位数的整型类型有8种:\n类型 描述 大小 表示范围 零值 int8 8 位整型 1字节 -2^7 ~ 2^7-1 0 int16 16位整型 2字节 -2^15 ~ 2^15-1 0 int32 32位整型 4字节 -2^31 ~ 2^31-1 0 int64 64位整型 8字节 -2^63 ~ 2^63-1 0 uint8 无符号8 位整型 1字节 0~255 0 uint16 无符号16位整型 2字节 0 ~ 2^16-1 0 uint32 无符号32位整型 4字节 0~2^31-1 0 uint64 无符号64位整型 8字节 0~2^63-1 0 这8种都与系统无关。好处是节省空间，大小可选择；缺点是移植性不好。\n# 浮点型 浮点型有2种：\n类型 描述 大小 表示范围 float32 32位浮点型数 4字节 -3.403E38~3.403E38 float64 64位浮点型数 8字节 -1.798E308~1.798E308 计算机中浮点数的保存通常都是近似值，可能因为精度问题而导致比较结果不准确。所以比较浮点数的零值或者两个浮点数是否相等一般采用math.Abs来比较。\n# 自定义类型 在Go中使用struct 和 type 关键字来自定义类型，这些类型由基本类型组成，Go使用_组合_的概念来替代_对象。_\nGo中结构体的内存排列是紧密的，但也有例外，不同的类型组合可能会导致结构体大小占用不一样。\n# 内存对齐 CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。 这么设计的目的，是减少 CPU 访问内存的次数，提升 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。\n内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后， 对该变量的访问就是原子的，这个特性在并发场景下至关重要。\n内存对齐提升性能的同时，也需要付出相应的代价。由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以 占用的内存会更大，这也是典型的 空间换时间 策略。\nGo中内存对齐规则(一个字32位下是4字节，64位下是8字节)：\n类型 大小 bool 1 个字节 intN, uintN, floatN, complexN N / 8个字节（例如 float64 是 8 个字节） int, uint, uintptr 1 个字 *T 1 个字 string 2 个字 （数据、长度） []T 3 个字 （数据、长度、容量） map 1 个字 func 1 个字 chan 1 个字 interface 2 个字 （类型、值） # example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1 word(字) = 8byte(字节) // 未对齐 type StructA struct { sex bool // 1字节 对齐到1个字 name string // 16字节 对齐到2个字 age int16 // 2字节 对齐到1个字 } // 对齐 type StructB struct { name string // 16字节 对齐到2个字 age int16 // 2字节 对齐到1个字 sex bool // 1字节 对齐到1个字 } func main() { fmt.Println(\u0026#34;structA length:\u0026#34;, unsafe.Sizeof(structA{})) // output: 32 fmt.Println(\u0026#34;structB length:\u0026#34;, unsafe.Sizeof(structB{})) // output: 24 } ","date":"2024-03-29T18:30:03+08:00","permalink":"https://bitfrost7.github.io/p/golang/type/","title":"Golang学习-基础数据类型"},{"content":" # Array数组 Golang中的数组是静态的，存储着一段相同内容的连续空间。\n# 基本使用 # 声明和初始化 在Go中数组的初始化主要有两种方式：一种是显示的指定数组大小，另一种是使用[...]自动推导数组大小的方式。\n1 2 arr1 := [3]int{1,2,3} arr2 := [...]int{1,2,3} 以上两种方式运行结果是一样的，后一种方式会在编译期间自动推导成第一种，只是Go为我们提供的语法糖。\nGo编译器在初始化数组时，会根据字面量的多少来进行不同的优化：\n当元素的数量小于或等于4个时，会将数组的元素直接放在栈上。\n当元素的数量大于4个时，会将数组中元素放置在静态区并在运行时取出。\n# 访问和读写 数组使用arr[n]来访问数组内元素，如果是一些简单的数组或者字符串的越界错误会在编译期间发现，而如果使用变量去访问数组，会在运行时触发程序的错误并导致崩溃退出。\n# 多维数组使用 在Go多维数组的初始化和一维类似：\n1 arr := [2][3]int{{1,2,3},{4,5,6}} # Slice切片 # 定义和初始化 切片是Go提供的基于array的一种动态数组，其长度并不像数组那样固定，我们可以向切片中追加元素或者进行扩容等操作。\n切片的初始化有三种方式：\n通过下标初始化获得切片或者数组的一部分\n使用字面量初始化新的切片\n使用关键字make来创建切片\n1 2 3 4 slice := arr[2:3] slice := []int{1,2,3} slice := make([]int,3) //make时还可以传入cap参数，当然，Go也会对参数进行校验，cap必须大于等于len 当Go编译器在创建切片时：\n如果切片发生逃逸或者切片的大小或容量特别大时，需要在运行时在堆上创建底层数组和切片。\n当切片特别小时，Go编译器会先在栈上或者静态存储区初始化数组，再通过下标(即第一种arr[2:3]的方式)得到切片。\n在运行时创建切片时，编译器会计算切片所需要的空间并在堆上申请一片连续的内存空间(空间不足会panic)：\n内存大小=元素大小x切片容量\n当内存分配完成，会返回底层数组的引用，并且和长度，容量合并成SliceHeader的结构体\n切片的底层数据结构如下：\n1 2 3 4 5 type SliceHeader struct { Data uintptr // 存储底层数组 Len int // 切片长度 Cap int // 切片分配的空间大小，小于Cap可以直接追加元素。 } 可以发现切片和数组主要不同在于cap字段。\n切片实际上是在数组的基础上加了一层抽象层，切片实际上是底层数组的一个引用，再加上长度和容量，当我们在运行时修改切片的长度和容量时，底层的数组可能会发生变化，而在上层引用看来切片并没有发生变化。\n切片和数组还有一点不同在于：切片只是在编译期间确定元素类型，而数组的编译期间就已经确定好了类型和长度。\n# 切片的访问 切片通过下标去访问元素：\n1 a := arr[3] //对切片的索引操作实际上会转化为地址的读取 在访问时，Go会进行边界检查,如果超出则会panic。\n切片可以获取长度和容量：\n1 2 3 arr := make([]int,10,20) l := len(arr) c := cap(arr) # 切片追加和扩容 在Go中使用append关键字对切片进行扩容, 扩容后会产生一个新的slice结构体，如果赋值回去原变量就相当于对原变量进行了扩容。\n1 2 arr := make([]int,3, 5) arr = append(arr, []int{1, 2}...) 当切片追加元素时，会根据：\n追加后切片长度小于等于容量\n追加后切片长度大于容量\n以及根据返回值是否覆盖原切片进行不同的流程\n如果触发了第二种情况，即容量不足的情况，Go会对切片进行扩容，扩容其实是为切片分配新的内存空间并拷贝原切片中元素的过程。\n在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：\nGo 1.18之前:\n如果期望容量大于当前容量的两倍就会使用期望容量； 如果当前切片的长度小于 1024 就会将容量翻倍； 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量； Go 1.18之后: 切片扩容不再以1024为临界点，而是设定了一个值为256的threshold。在计算完容量之后，会根据容量和元素大小相乘，如果新的切片发生了内存溢出或者请求内存大于上限则会直接panic。 如果期望容量大于当前容量的两倍就会使用期望容量； 当原切片容量 \u0026lt; threshold 的时候，新切片容量变成原来的 2 倍； 当原切片容量 \u0026gt; threshold 的时候，进入一个循环，每次容量增加(旧容量+threshold*3) / 4； # 切片拷贝 在Go中使用copy关键字进行切片的复制，实际上底层使用的是对内存的复制。\nGo对切片仅支持append和copy两种操作，需要注意的是在大切片中进行这两种操作会比较消耗资源。\n# 案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func func1(a []int) { b := make([][]int, 0) for i := 0; i \u0026lt; 10; i++ { t := append(a, i) b = append(b, t) } } // 需要理解到append的底层实现： 1. 判断原切片是否要扩容 2. 如果要扩容，先new一个新的数组，再copy值到新的数组；如果不需要扩容。直接追加元素 3. append操作实际上会生成一个slice结构体，如果赋值回去，原始切片会增加len；如果不赋值回去，则len不变。 func func2() { a := [...]int{0, 1, 2, 3} x := a[:1] // { pointer:-\u0026gt;a len:1 cap: 4} y := a[2:] x = append(x, y...) x = append(x, y...) fmt.Println(a, x) } //需要理解到[:]运算的本质 //实际上是创建一个切片的引用，底层数组还是指向原来切片，但len和cap发生变化。具体看是如何切割。 ","date":"2024-03-29T16:40:30+08:00","permalink":"https://bitfrost7.github.io/p/golang/slice/","title":"Golang学习-数组和切片"},{"content":" # 关键字 Go共有25个保留关键字\n# 包管理（2个）： # import 用于导入包，这样就可以使用包中被导出的标识符。导入格式如下：\n1 2 3 4 import \u0026#34;fmt\u0026#34; //直接import import f \u0026#34;fmt\u0026#34; //添加包别名 import . \u0026#34;fmt\u0026#34; //代表导入包，使用时不用加包名 import _ \u0026#34;fmt\u0026#34; //不使用包中的标识符，只需要包的副作用（init函数，包级变量...） # package 用于声明包的名称，需放在go文件所有代码的最前面。一个包由一个或多个go源文件组成，需放在同一个目录下，且同一个目录下的这些go文件的package的名字只能有一个，且不能为\u0026quot;_\u0026quot;。 package \u0026lt;packagename\u0026gt;\n# 程序实体声明与定义（8个）： # chan 用于声明channel(信道)。信道提供一种机制使两个并发执行的函数实现同步，并通过传递具体元素类型的值来通信。\n1 2 3 chan T // 可以被用来发送和接收类型T的值 chan\u0026lt;- T // 只能被用来发送浮点数 \u0026lt;-chan T // 只能被用来接收整数 # const 用于定义常量，一旦创建，不可赋值修改\n# func func 用于定义函数。Go函数支持可变参数且返回值支持多个，但不支持默认参数。如果函数存在多个返回值形参则需要使用小括号括起来，定义格式如下：\n1 2 3 func funcName(){} //无参无返回值 func funcName(t T) T {} //有参有返回值 func funcName(t T, list ...T) (T1,T1) {} //有变参有多个返回值 # interface interface 用于定义接口。一个接口是一个方法集，如果一个类型实现了一个接口中的所有方法集，那么说明该类型实现此接口。接口类型变量可以存储任何实现了该接口的类型的值。特别的，interface{}表示空接口类型，默认地，所有类型均实现了空接口，所以interface{}可以接收任意类型值。\n# map map 用于声明映射变量。映射属容器类类型，是一个同种类型元素的无序组，通过唯一的键可以获取对应的值。可以使用 make 创建 map 变量，在定义 map 时可以省略容量，超出容量时会自动扩容，但尽量提供一个合理的初始值。未初始化的值为 nil。\n# struct struct 用于定义结构体。结构体属容器类型，是多个相同或不同类型值的集合 。一个结构体的零值是类型集合中所有类型的零值。\n# type type 用于定义类型，比如定义 struct、interface、func 与等价类型。\n# var var 用于申明函数级变量和包级变量。\n# 程序流程控制（15个）： # 循环 for 是 Go 中唯一用于循环结构的关键词, 有三种使用方式：1. 单条件 2. 循环变量 3 range\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // for 单条件用法 相当于while i := 0 for i \u0026lt; 10 { fmt.Println(i) i++ } // for 循环变量 for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } // for range 用法 s := []int{1, 2, 3} for i, v := range s { fmt.Println(i, v) } break continue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // break 跳出本次循环 for i := 0; i \u0026lt; 10; i++ { if i == 5 { break } fmt.Println(i) } // continue 跳过本次循环 for i := 0; i \u0026lt; 10; i++ { if i == 5 { continue } fmt.Println(i) } # 条件语句 if else else if 1 2 3 4 5 6 7 if i == 1 { fmt.Println(\u0026#34;i == 1\u0026#34;) } else if i == 2 { fmt.Println(\u0026#34;i == 2\u0026#34;) } else { fmt.Println(\u0026#34;i != 1 \u0026amp;\u0026amp; i != 2\u0026#34;) } switch default case\n1 2 3 4 5 6 7 8 switch i { case 1: fmt.Println(\u0026#34;i == 1\u0026#34;) case 2: fmt.Println(\u0026#34;i == 2\u0026#34;) default: fmt.Println(\u0026#34;i != 1 \u0026amp;\u0026amp; i != 2\u0026#34;) } # 跳转控制 return Go中一个函数可以有一个或者多个返回值，返回值通过return指定。\nreturn关键字中指定了参数时，返回值可以不用名称。如果return省略参数，则返回值部分必须带名称，当返回值带有名称时，必须使用()包起来 在一个函数块里，任何在return之后的代码都不会执行 defer goto # 并发控制 go select ","date":"2024-03-29T15:54:28+08:00","permalink":"https://bitfrost7.github.io/p/golang/","title":"Golang学习-关键字"}]