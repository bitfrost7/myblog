[{"content":" # Context介绍 在Go的并发控制中，经常会需要用到父协程和子协程进行通信或者控制，比如说控制协程结束，超时控制，参数传递等场景。与之对应的，context.Context提供了 BackGround，WithCancel，WithTimeout ，WithValue 四种 context。\n# 功能介绍： BackGround，所有context的root，其他context都应该从它继承。 WithCancel，基于父context创建一个可取消的context，当 cancelFunc() 被调用时，所有监听ctx.Done()的接收者都会立刻解除阻塞，并且同时会递归的取消所有子context。 WithTimeout ，基于父context创建一个带有定时器的context，同样也会返回cancelFunc来显式取消 WithValue，基于父context创建一个带有kv对的context，并且可以继承父context的所有，包括kv对，定时器以及cancelFunc，子context可以对父context的kv对进行修改。 ","date":"2024-04-02T17:32:17+08:00","permalink":"https://bitfrost7.github.io/p/golang/context/","title":"Golang学习- context使用"},{"content":" # 介绍 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。 单例模式有两个特点：\n一个类只有一个实例 该实例只有一个全局访问节点 # 实现 单例模式的实现需要三个必要的条件：\n单例类的构造函数必须是私有的，这样才能将类的创建权控制在类的内部，从而使得类的外部不能创建类的实例。 单例类通过一个私有的静态变量来存储其唯一实例。 单例类通过提供一个公开的静态方法，使得外部使用者可以访问类的唯一实例。 单例的实现一共有五种方式： # 饿汉式（静态初始化） 天生线程安全，效率高 如果实例没有被使用，会造成内存浪费，并且生命周期固定，比方说要求根据配置文件变化，不能重新初始化或替换实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package singleton type Singleton struct { } var instance *Singleton func init() { instance = \u0026amp;Singleton{} } func GetInstance() *Singleton { return instance } # 懒汉式 (用时初始化) 线程不安全 1 2 3 4 5 6 7 8 9 10 11 12 13 package singleton type Singleton struct { } var instance *Singleton func GetInstance() *Singleton { if instance == nil { instance = \u0026amp;Singleton{} } return instance } # 双重检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package singleton import \u0026#34;sync\u0026#34; type Singleton struct { } var ( instance *Singleton once sync.Once ) func GetInstance() *Singleton { once.Do(func() { instance = \u0026amp;Singleton{} }) return instance } ","date":"2024-03-29T22:24:18+08:00","permalink":"https://bitfrost7.github.io/p/design-patterns/singleton/","title":"设计模式-单例"},{"content":" # 标准库容器 Go语言中有一个 container 包，提供了三种常用的数据结构：list双向链表，heap堆，ring环\n# List 链表是一种常见的数据结构，它由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表的优点是在插入和删除操作时非常高效 O(1)，而在访问时效率较低 O(n)。链表有单向链表、双向链表和循环链表等多种类型，链表还有许多变种，如哈希链表、跳表等。 在Go中cotainer/list 实现了双向链表。 数据结构如下：\n1 2 3 4 5 6 7 8 9 10 type Element struct { next, prev *Element list *List Value any } type List struct { root Element // sentinel list element, only \u0026amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element } 链表头尾节点使用了哨兵节点，方便删除和插入。\n# List常用api 名称 函数参数 作用 New 无 new一个list返回 Front 无 返回头节点 Back 无 返回尾节点 Remove element 移除节点 PushFront value any 头部添加元素 PushBack value any 尾部添加元素 InsertBefore value any , mark element 在mark后添加元素 MoveToFront e element 移动节点到头部 PushBackList other *list 将另一个列表添加进去 1 2 3 4 // 遍历一个链表 for e := a.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } # Heap Go语言container包中， heap 为所有实现了 heap.Interface 的类型提供了堆操作。\n堆，其实是一个优先级队列，这个队列里按照优先级排，优先级高的在堆顶，优先级低的在堆底。 一个堆是一个完全二叉树，树中不存在气泡，是连续存储的，所以可以直接由数组实现。\nGolang中的堆是最小堆，父节点的值总是小于子节点的值，所以root节点的值最小。\n# 接口定义 Go中要使用heap，必须实现heap.Interface:\n1 2 3 4 5 type Interface interface { sort.Interface Push(x any) // add x as element Len() Pop() any // remove and return element Len() - 1. } 除了实现pop和push之外 还需要实现sort接口。\n# 提供函数 heap接口提供了几个堆操作的函数：\nInit 用于在使用堆之前对堆进行初始化。 1 2 3 4 5 6 7 func Init(h Interface) { // heapify n := h.Len() for i := n/2 - 1; i \u0026gt;= 0; i-- { down(h, i, n) } } Pop/Push 用于弹出或者推入元素 1 2 3 4 5 6 7 8 9 10 11 12 13 // Push 函数将值为 x 的元素推入到堆里面，该函数的复杂度为 O(log(n)) 。 func Push(h Interface, x any) { h.Push(x) up(h, h.Len()-1) } // Pop 函数根据 Less 的结果， 从堆中移除并返回具有最小值的元素。 // 等同于执行 Remove(h, 0)，复杂度为 O(log(n))。（n 等于 h.Len() ）。 func Pop(h Interface) any { n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() } Remove 移除元素 1 2 3 4 5 6 7 8 9 10 func Remove(h Interface, i int) any { n := h.Len() - 1 if n != i { h.Swap(i, n) if !down(h, i, n) { up(h, i) } } return h.Pop() } Fix 有时候我们会修改i上的值，这时需要调用Fix来修复元素顺序。尽管可以先删除i的值，再push，但是直接修改加Fix的成本会小一些。 1 2 3 4 5 func Fix(h Interface, i int) { if !down(h, i, h.Len()) { up(h, i) } } heap包里还有几个关键函数:\nup 将所给索引的元素向上调整到其正确的位置，以满足堆的性质。 down 将所给索引 的元素向下调整至其子节点中合适的位置，保证堆的性质。并且返回是否下沉，即返回true表示发生了下沉，false表示未发生下沉。 # 使用heap实现一个优先级队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package main import ( \u0026#34;container/heap\u0026#34; \u0026#34;fmt\u0026#34;) // 定义一个实现了heap.Interface的结构体 type PriorityQueue struct { items PriorityQueueItems } type PriorityQueueItem struct { Value int // 具体的值 Priority int // 优先级，这里假设数值越大的优先级越高 index int // 用于heap.Interface所需的索引 } type PriorityQueueItems []PriorityQueueItem // 实现heap.Interface的三个方法 func (pq PriorityQueueItems) Len() int { return len(pq) } func (pq PriorityQueueItems) Less(i, j int) bool { return pq[i].Priority \u0026gt; pq[j].Priority } // 大顶堆 func (pq PriorityQueueItems) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pq *PriorityQueueItems) Push(x interface{}) { n := len(*pq) item := x.(PriorityQueueItem) item.index = n *pq = append(*pq, item) } func (pq *PriorityQueueItems) Pop() interface{} { old := *pq n := len(old) item := old[n-1] old[n-1] = PriorityQueueItem{} *pq = old[0 : n-1] return item } // 优先级队列对外提供的方法 func (pq *PriorityQueue) Push(value int, priority int) { item := PriorityQueueItem{ Value: value, Priority: priority, } heap.Push(\u0026amp;pq.items, item) } func (pq *PriorityQueue) Pop() (value int, ok bool) { if pq.items.Len() == 0 { return 0, false } item := heap.Pop(\u0026amp;pq.items).(PriorityQueueItem) return item.Value, true } func NewPriorityQueue() *PriorityQueue { return \u0026amp;PriorityQueue{items: make(PriorityQueueItems, 0)} } func main() { pq := NewPriorityQueue() pq.Push(3, 1) pq.Push(1, 3) pq.Push(2, 2) for pq.items.Len() \u0026gt; 0 { value, _ := pq.Pop() fmt.Println(value) // 输出顺序应为：3, 2, 1 } } # Ring 在 Go 语言的标准库中，container/ring 包提供了环形缓冲区（Ring Buffer）的实现，也称为循环队列。环形缓冲区是一种固定大小的缓冲区，其特点是当缓冲区满时，新的数据会覆盖最旧的数据，形成一个首尾相连的环状结构。这种数据结构常用于缓存最近使用的数据、限流等场景。\n# 提供函数 New() 创建一个新的环形缓冲区实例，具有给定的大小。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func New(n int) *Ring { if n \u0026lt;= 0 { return nil } r := new(Ring) p := r for i := 1; i \u0026lt; n; i++ { p.next = \u0026amp;Ring{prev: p} p = p.next } p.next = r r.prev = p return r } Link()和Unlink() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // LInk用于连接另一个`ring` func (r *Ring) Link(s *Ring) *Ring { n := r.Next() if s != nil { p := s.Prev() // Note: Cannot use multiple assignment because // evaluation order of LHS is not specified. r.next = s s.prev = r n.prev = p p.next = n } return n } // Unlink用于移除一个元素 func (r *Ring) Unlink(n int) *Ring { if n \u0026lt;= 0 { return nil } return r.Link(r.Move(n + 1)) } Prev() Next() Move() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Prev返回指向前一个元素的环形缓冲区节点 func (r *Ring) Next() *Ring { if r.next == nil { return r.init() } return r.next } // Next返回指向下一个元素的环形缓冲区节点 func (r *Ring) Prev() *Ring { if r.next == nil { return r.init() } return r.prev } // Move将环形缓冲区的指针移动n个位置，正数表示向前移动，负数表示向后移动 func (r *Ring) Move(n int) *Ring { if r.next == nil { return r.init() } switch { case n \u0026lt; 0: for ; n \u0026lt; 0; n++ { r = r.prev } case n \u0026gt; 0: for ; n \u0026gt; 0; n-- { r = r.next } } return r } Len Do 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Len 返回环形缓冲区中有效元素的数量。 func (r *Ring) Len() int { n := 0 if r != nil { n = 1 for p := r.Next(); p != r; p = p.next { n++ } } return n } // Do 对环形缓冲区中的每个元素执行给定的函数 func (r *Ring) Do(f func(any)) { if r != nil { f(r.Value) for p := r.Next(); p != r; p = p.next { f(p.Value) } } ","date":"2024-03-29T22:04:44+08:00","permalink":"https://bitfrost7.github.io/p/golang/container/","title":"Golang学习-container库"},{"content":" # 哈希表概念 哈希表是一种十分重要的数据结构，具有O(1)的读写速度，并且存储着键值对之间映射关系。\n哈希函数(hash)，也叫做散列函数，本质上是一种抽样函数，好比原来有一长串字符aabbccddeeff，抽样后成了abcdef，所以，哈希函数有个特点：输入范围必然小于输出范围。但在哈希表中，key值往往是无限的，通过哈希计算后必定会出现相同的值，被称为哈希冲突或者哈希碰撞。哈希冲突无法解决，比较实际的方式是通过让哈希函数的结果能够尽可能的均匀分布，但假设发生了哈希冲突，常用的解决方式有两种——开放寻址法和拉链法。\n# 开发寻址法 开放寻址法是一种解决哈希冲突的方法，这种方法的核心在于依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中，这种方式实现的哈希表底层是一个定长的数组，当我们往哈希表中写入一个数据时：\n根据唯一key计算哈希值\n通过哈希值计算出索引：inedx := hash(key)%len(array)\n索引处若为空直接插入，如果已经有值则找到往后第一个不为空的地方插入\n查找的逻辑相似，主要在于第3步，如果索引处没有找到相应的键值对，则往后遍历直到遍历完或者找到为止。\n开放寻址法的有好处是底层数据架构足够简单，缺点也很明显，当元素个数趋近于数组大小时，哈希表的效率会急速下降，一旦元素个数等于数组大小时，查找一个键值对的复杂度是O(n)，需要遍历整个数组。\n# 拉链法 拉链法是一种基于数组和链表的结构，数组元素是一个链表，形似拉链。\n当我们写入一个kv时：\n根据唯一key值计算hash值\n通过hash值的低B位 来计算放到那个桶(bucket)里\n如果桶中找到key相同的链表节点则更新该kv对，若非没有找到则在链表结尾追加该kv对\n查找的逻辑类似，于开放寻址法不同，拉链法即使存放元素个数和数组大小相同，查找和存取的效率远远好过开放寻址法。在开放寻址法中，有装载因子这一概念：\n装载因子:= 元素个数 / 桶数量\n拉链法的装载因子越大效率越低，大多数情况下装载因子不会超过1，如果装载因子过大，会触发桶的扩容，设计重新计算hash索引，但即便10的装载因子仍然比O(n)的效率要高。\n# Go中map实现 Go语言使用了两个主要结构表示哈希表，hmap和bmap，关于哈希表的结构在$GOROOT\\src\\runtime\\map.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type hmap struct { count int //代表哈希表中的元素个数 flags uint8 B uint8 //哈希表buckets的个数，因为buckets一般是2的倍数，所以B为2的对数 noverflow uint16 hash0 uint32 // hash seed buckets unsafe.Pointer //bucket数组的指针 oldbuckets unsafe.Pointer //哈希表在扩容之前保存之前buckets的指针 nevacuate uintptr extra *mapextra } type mapextra struct { overflow *[]*bmap oldoverflow *[]*bmap nextOverflow *bmap } hmap中存储元素的桶的结构是bmap，每一个bmap中存储着8个kv对，以及8个tophash，当单个桶已经装满时，就会存储到溢出桶overflow中去，当溢出桶也逐渐变多时，也会触发哈希表的扩容。\n1 2 3 4 5 6 7 type bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr } # 初始化 在Go中一般使用字面量来初始化哈希表：\n1 2 3 4 m := make(map[string]int, 3) m[\u0026#34;1\u0026#34;] = 2 m[\u0026#34;3\u0026#34;] = 4 m[\u0026#34;5\u0026#34;] = 6 Go初始化一个map的过程主要是以下步骤：\n计算哈希表所占用的内存大小是否溢出\n获取一个随机的哈希种子\n根据kv对的数量来计算桶的数量\n创建桶数组buckets\n创建溢出桶overflow ，此时会根据正常桶的数量来创建溢出桶： 当桶的个数小于2^4时，此时使用溢出桶的可能比较小，会省略创建溢出桶\n当桶的个数大于2^4时，则额外创建2^(B-4)个溢出桶\n溢出桶和正常桶的内存分布是连续的\n# 读写 哈希表的读主要分为直接获取和遍历：\n1 2 3 4 value := m[key] for k,v := range m{ //k,v } 哈希表的写操作分为：插入，修改和删除:\n1 2 3 m[newkey] = newvalue m[key] = value delete(m,key) # 访问 哈希表访问的时候有两种方式，一种是只返回value，还有一种是返回value和一个bool值,来表示哈希表中是否存在这个键值对。\n1 2 v := hashtable[k] v,ok := hashtable[k] 在根据key值查找哈希表时，会经过以下步骤：\n通过哈希表设置的哈希函数、种子获取当前键对应的哈希\n计算该键值对所在的桶序号和哈希高位的 8 位数字 计算桶序号：哈希值低B位，比如说B=5，取低5位00100，也就是第4个桶\n将哈希值高8位和Tophash对比，确定在bucket中那个槽位\n当发现桶中的 tophash 与传入键的 tophash 匹配之后，会通过指针和偏移量获取哈希中存储的键 keys[0]并与 key 比较，如果两者相同就会获取目标值的指针 values[0] 并返回\n当需要返回bool值的时候会根据键值对是否存在再返回，更推荐这种方式。\n当哈希表处于扩容状态时，如果哈希表的 oldbuckets 存在时，对哈希表的访问会先定位到旧桶并在该桶没有被分流时从中获取键值对。\n# 写入 哈希表在写入时，主要步骤：\n根据key计算hash，找到对应的桶；\n通过hash(key)和tophash进行比较，找到对应的槽位；\n遍历正常桶和溢出桶，如果存在，返回对应val内存地址；如果不存在，则会为新键值对规划存储的内存地址。如果当前桶已经满了，则会创建新的溢出桶来保存数据，同时增加hmap中的noverflow计数器\n# 扩容 在Go中往哈希表中插入数据时，当桶中的数据过多，原本O(1)的读写效率可能退化到O(n)，这时候就需要扩容，哈希表会在插入新元素的时候进行判断：\n装载因子大于6.5时, 装载因子：loadFactor := count / (2^B)，此时会进行翻倍扩容，扩容后newbuckets = 2^(B+1)\n溢出桶的个数过多时：\n当B小于15时，如果此时溢出桶overflow 的数量超过 2^B，也就是正常桶的数量\n当B大于15时，如果此时溢出桶overflow的数量超过了2^15\n此时会进行等量扩容，因为溢出桶过多说明此时哈希表中进行了大量的插入和删除操作，导致kv分散，降低了哈希表查找的效率。\nGo中哈希表的扩容不是一个原子过程，哈希表会创建一组新桶和溢出桶，再将当前桶挂到hmap中oldbuckets字段，此时并没有对数据进行拷贝，而是在传入数据时将旧桶中的数据进行分流到新桶中去，避免了一次拷贝带来的性能压力，被叫做渐进式扩容。\n哈希表扩容的详细流程：\n当哈希表判断需要进行扩容时，调用hashGrow函数，进入扩容状态，此时会创建新桶和溢出桶，并将当前桶挂到oldbuckets中\n当哈希表调用插入或者删除时，会判断当前哈希表处于扩容状态，并且调用growWork函数进行数据迁移\n在迁移过程中，会根据翻倍扩容还是等量扩容进入不同的迁移流程： 如果是等量扩容，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。\n如果是翻倍扩容，需要重新计算hash，再决定它落在那个桶中，这一阶段会涉及分流:\n举个例子：原始 B = 2，1号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 10 决定它们落在 2 号桶，现在 B 变成 3，所以 010，110 分别落入 2、6 号桶。\n因为迁移的过程并非原子，所以哈希表会在迁移过程中保留一个上下文结构runtime.evacDst，等量扩容为一个，翻倍扩容为两个。\n当哈希表完成扩容之后，会清空oldbuckets，以加速GC。\n# 删除 哈希表删除需要用到delete关键字，删除的逻辑和插入很类似，如果找不到删除的key值，或者map为空不会进行任何操作，当map处于扩容阶段，会进行桶中元素的分流，分流之后再完成键值对的删除。\n# 使用嵌套map 在Go中 可以通过类似于map[string]map[string]int这样的方式定义嵌套map，表示声明一个键为string，值为map[string]int的map。\n在Go中使用未初始化的map会panic，所以以下代码会运行报错：\n1 2 3 m := make(map[string]map[string]int) m[\u0026#34;aa\u0026#34;][\u0026#34;b\u0026#34;] = 1 panic: assignment to entry in nil map 正确使用应该先初始化内部map：\n1 2 3 4 m := make(map[string]map[string]int) m[\u0026#34;aa\u0026#34;] = make(map[string]int) m[\u0026#34;aa\u0026#34;][\u0026#34;bb\u0026#34;] = 1 fmt.Println(m) # 并发安全的map Go 语言原生 map 并不是线程安全的，对它进行并发读写操作的时候，需要加锁。\n在Go1.9引入了并发安全的map——sync.map。\n使用 sync.map 之后，对 map 的读写，不需要加锁。并且它通过空间换时间的方式，使用 read 和 dirty 两个 map 来进行读写分离，降低锁时间来提高效率。\n1 2 3 4 5 6 type Map struct { mu Mutex read atomic.Value // readOnly dirty map[interface{}]*entry misses int } # 使用sync.map # GC中的map ","date":"2024-03-29T21:33:25+08:00","permalink":"https://bitfrost7.github.io/p/golang/hashmap/","title":"Golang学习-哈希表"},{"content":" # 字符串基本使用 # 声明和初始化字符串 在Go中要声明一个字符串可以这样：\n1 2 3 var s string s := \u0026#34;hello world\u0026#34; s := \u0026#34;你好\u0026#34; //Go也支持中文字符串 # 格式化输出 在Go中格式化输出字符串主要使用fmt包中的Printf和Sprintf，例如：\n1 2 3 4 a := \u0026#34;世界\u0026#34; fmt.Printf(\u0026#34;hello,%s\u0026#34;, a) str := fmt.Sprintf(\u0026#34;hello,%s\u0026#34;, a) fmt.Println(str) 注意：Sprintf会返回格式化后的字符串，而Printf仅仅只能打印\n# 字符串编码 Go中字符串使用的是UTF-8编码的Unicode字符序列，需要注意的是在编写Go代码时，需要将编辑器保存设置为UTF-8格式，否则可能会出现编译错误。\n在Go中汉字通常占3个字节，而英文字母只需要1个。\n# 字符串相关函数 Go中字符串相关的函数都在strings包中\n前缀后缀 1 2 3 4 //判断字符串s前缀是否是prefix HasPrefix(s, prefix string) bool //判断字符串s后缀是否是suffix HasSuffix(s, suffix string) bool 是否包含 1 2 3 4 5 6 //字符串s是否包含子串substr Contains(s string, substr string) bool //字符串是否包含chars内任一字符 ContainsAny(s string, chars string) bool //字符串是否包含某一字符 ContainsRune(s string, r rune) bool 判断索引位置 1 2 3 4 //返回字符串s中第一个substr的位置，如果没有找到返回-1 Index(s, substr string) int //返回字符串s最后一个substr的位置，如果没有找到返回-1 LastIndex(s, substr string) int 字符串替换 1 2 3 4 5 6 7 8 //将字符串s的前n个字符串old替换为new，返回新字符串，如果n=-1则替换所有的new为old Replace(s, old, new string, n int) string //例子: s := \u0026#34;hello,world\u0026#34; new := strings.Replace(s, \u0026#34;l\u0026#34;, \u0026#34;j\u0026#34;, -1) //把s中的所有\u0026#39;l\u0026#39;替换为\u0026#39;j\u0026#39; fmt.Println(s, new) //输出: hello,world hejjo,worjd 字符串计数 1 2 //返回s中出现substr的次数，如果substr为空，则返回len(s)+1 Count(s, substr string) int 大小写转换 1 2 3 4 //将字符串s转换为小写字母返回 ToLower(s string) string //将字符串s转换为大写字母返回 ToUpper(s string) string 修剪字符串 1 2 3 4 5 6 7 8 //剔除掉字符串s前后的cutset Trim(s, cutset string) string //仅剔除字符串s开头的cutset TrimLeft(s, cutset string) string //仅剔除字符串s结尾的cutset TrimRight(s, cutset string) string //剔除字符串s开头结尾的空格 TrimSpace(s string) string 分割和拼接 1 2 3 4 5 6 //将字符串s以空白字符为分隔符切分成数组 Fields(s string) []string //将字符串s以sep为分隔符切分成数组 Split(s, sep string) []string //将字符串数组elems使用sep拼接 返回新字符串 Join(elems []string, sep string) string # 字符串底层原理 # 字符串数据结构 在Go中字符串的底层实际上是一个struct：\n1 2 3 4 type StringHeader struct { Data uintptr Len int } 字符串结构体有一个byte数组指针和一个代表长度的len。\nGo使用\u0026quot;\u0026quot;来声明单行字符串，```来声明多行字符串。\n1 2 3 s1 := \u0026#34;hello world!\u0026#34; s2 := `hello world!` 在Go中string类型是不可变的，在分配内存时会被分配到只读区域，同样在其他语言中字符串类型也是不可变的，这样做的原因是：\n安全：大部分密码都是以字符串形式存储，如果可以修改会造成安全漏洞\n性能：通常HashMap的key一般会是字符串，字符串不可变就能进行hashcode缓存避免重复计算\nGo中并没有字符串常量池这种设计，意味着每次创建相同的字符串会重复分配内存，在某些情况下可能会成为瓶颈，可以自己实现字符串常量池来避免。\n如果需要对字符串强行进行修改，如果字符串只包含ASCII码以内的字符，可以先转换为[]byte类型，在进行修改，再转换为字符串。但是这种方式并没有改变内存中的不可变区域，而是在新的内存区域。\n# 单引号和双引号的区别 在Go中单引号和双引号是由本质区别的，单引号 — rune类型，其实就相当于int32类型，占4个字节，在Unicode编码中最大4个字节就能表示一个字符。比方说：fmt.Println('a') 结果是97，是ASCII码表中的a的值。双引号—string类型，在Go中双引号表示字符串类型，Go 语言中字符串默认是 UTF-8 编码的 Unicode 字符序列，也就是byte数组\n# rune和string异同点 类型 rune（单引号） string（双引号） 底层类型 int32 byte数组 是否能互相转换 是 是 是否可变 不可变 不可变 ","date":"2024-03-29T18:36:49+08:00","permalink":"https://bitfrost7.github.io/p/golang/string/","title":"Golang学习-字符串"},{"content":" # Go中的数据类型介绍 在Go中数据类型分为3大类：基础类型，如int，float，bool这些基础类型。内置类型，比如slice，map，channel这些。派生类型，从基础类型或者内置类型组合自定义出来的类型，也可以看作Go中的\u0026quot;对象\u0026quot;。\n字长：计算机CPU总线的位宽，一般有32位和64位，限制了cpu一次能读取的数据\n字节：一位0或者1就是1bit，1byte = 8bit，1024 byte = 1kb， 1024 kb = 1 MB，1024 MB = 1GB # 数字类型 在Go中int 类型的大小是根据底层系统的字长决定，32位系统下是4字节，64位系统下是8字节。而固定位数的整型类型有8种:\n类型 描述 大小 表示范围 零值 int8 8 位整型 1字节 -2^7 ~ 2^7-1 0 int16 16位整型 2字节 -2^15 ~ 2^15-1 0 int32 32位整型 4字节 -2^31 ~ 2^31-1 0 int64 64位整型 8字节 -2^63 ~ 2^63-1 0 uint8 无符号8 位整型 1字节 0~255 0 uint16 无符号16位整型 2字节 0 ~ 2^16-1 0 uint32 无符号32位整型 4字节 0~2^31-1 0 uint64 无符号64位整型 8字节 0~2^63-1 0 这8种都与系统无关。好处是节省空间，大小可选择；缺点是移植性不好。\n# 浮点型 浮点型有2种：\n类型 描述 大小 表示范围 float32 32位浮点型数 4字节 -3.403E38~3.403E38 float64 64位浮点型数 8字节 -1.798E308~1.798E308 计算机中浮点数的保存通常都是近似值，可能因为精度问题而导致比较结果不准确。所以比较浮点数的零值或者两个浮点数是否相等一般采用math.Abs来比较。\n# 自定义类型 在Go中使用struct 和 type 关键字来自定义类型，这些类型由基本类型组成，Go使用_组合_的概念来替代_对象。_\nGo中结构体的内存排列是紧密的，但也有例外，不同的类型组合可能会导致结构体大小占用不一样。\n# 内存对齐 CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。 这么设计的目的，是减少 CPU 访问内存的次数，提升 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。\n内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后， 对该变量的访问就是原子的，这个特性在并发场景下至关重要。\n内存对齐提升性能的同时，也需要付出相应的代价。由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以 占用的内存会更大，这也是典型的 空间换时间 策略。\nGo中内存对齐规则(一个字32位下是4字节，64位下是8字节)：\n类型 大小 bool 1 个字节 intN, uintN, floatN, complexN N / 8个字节（例如 float64 是 8 个字节） int, uint, uintptr 1 个字 *T 1 个字 string 2 个字 （数据、长度） []T 3 个字 （数据、长度、容量） map 1 个字 func 1 个字 chan 1 个字 interface 2 个字 （类型、值） # example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1 word(字) = 8byte(字节) // 未对齐 type StructA struct { sex bool // 1字节 对齐到1个字 name string // 16字节 对齐到2个字 age int16 // 2字节 对齐到1个字 } // 对齐 type StructB struct { name string // 16字节 对齐到2个字 age int16 // 2字节 对齐到1个字 sex bool // 1字节 对齐到1个字 } func main() { fmt.Println(\u0026#34;structA length:\u0026#34;, unsafe.Sizeof(structA{})) // output: 32 fmt.Println(\u0026#34;structB length:\u0026#34;, unsafe.Sizeof(structB{})) // output: 24 } ","date":"2024-03-29T18:30:03+08:00","permalink":"https://bitfrost7.github.io/p/golang/type/","title":"Golang学习-基础数据类型"},{"content":" # Array数组 Golang中的数组是静态的，存储着一段相同内容的连续空间。\n# 基本使用 # 声明和初始化 在Go中数组的初始化主要有两种方式：一种是显示的指定数组大小，另一种是使用[...]自动推导数组大小的方式。\n1 2 arr1 := [3]int{1,2,3} arr2 := [...]int{1,2,3} 以上两种方式运行结果是一样的，后一种方式会在编译期间自动推导成第一种，只是Go为我们提供的语法糖。\nGo编译器在初始化数组时，会根据字面量的多少来进行不同的优化：\n当元素的数量小于或等于4个时，会将数组的元素直接放在栈上。\n当元素的数量大于4个时，会将数组中元素放置在静态区并在运行时取出。\n# 访问和读写 数组使用arr[n]来访问数组内元素，如果是一些简单的数组或者字符串的越界错误会在编译期间发现，而如果使用变量去访问数组，会在运行时触发程序的错误并导致崩溃退出。\n# 多维数组使用 在Go多维数组的初始化和一维类似：\n1 arr := [2][3]int{{1,2,3},{4,5,6}} # Slice切片 # 定义和初始化 切片是Go提供的基于array的一种动态数组，其长度并不像数组那样固定，我们可以向切片中追加元素或者进行扩容等操作。\n切片的初始化有三种方式：\n通过下标初始化获得切片或者数组的一部分\n使用字面量初始化新的切片\n使用关键字make来创建切片\n1 2 3 4 slice := arr[2:3] slice := []int{1,2,3} slice := make([]int,3) //make时还可以传入cap参数，当然，Go也会对参数进行校验，cap必须大于等于len 当Go编译器在创建切片时：\n如果切片发生逃逸或者切片的大小或容量特别大时，需要在运行时在堆上创建底层数组和切片。\n当切片特别小时，Go编译器会先在栈上或者静态存储区初始化数组，再通过下标(即第一种arr[2:3]的方式)得到切片。\n在运行时创建切片时，编译器会计算切片所需要的空间并在堆上申请一片连续的内存空间(空间不足会panic)：\n内存大小=元素大小x切片容量\n当内存分配完成，会返回底层数组的引用，并且和长度，容量合并成SliceHeader的结构体\n切片的底层数据结构如下：\n1 2 3 4 5 type SliceHeader struct { Data uintptr // 存储底层数组 Len int // 切片长度 Cap int // 切片分配的空间大小，小于Cap可以直接追加元素。 } 可以发现切片和数组主要不同在于cap字段。\n切片实际上是在数组的基础上加了一层抽象层，切片实际上是底层数组的一个引用，再加上长度和容量，当我们在运行时修改切片的长度和容量时，底层的数组可能会发生变化，而在上层引用看来切片并没有发生变化。\n切片和数组还有一点不同在于：切片只是在编译期间确定元素类型，而数组的编译期间就已经确定好了类型和长度。\n# 切片的访问 切片通过下标去访问元素：\n1 a := arr[3] //对切片的索引操作实际上会转化为地址的读取 在访问时，Go会进行边界检查,如果超出则会panic。\n切片可以获取长度和容量：\n1 2 3 arr := make([]int,10,20) l := len(arr) c := cap(arr) # 切片追加和扩容 在Go中使用append关键字对切片进行扩容, 扩容后会产生一个新的slice结构体，如果赋值回去原变量就相当于对原变量进行了扩容。\n1 2 arr := make([]int,3, 5) arr = append(arr, []int{1, 2}...) 当切片追加元素时，会根据：\n追加后切片长度小于等于容量\n追加后切片长度大于容量\n以及根据返回值是否覆盖原切片进行不同的流程\n如果触发了第二种情况，即容量不足的情况，Go会对切片进行扩容，扩容其实是为切片分配新的内存空间并拷贝原切片中元素的过程。\n在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：\nGo 1.18之前:\n如果期望容量大于当前容量的两倍就会使用期望容量； 如果当前切片的长度小于 1024 就会将容量翻倍； 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量； Go 1.18之后: 切片扩容不再以1024为临界点，而是设定了一个值为256的threshold。在计算完容量之后，会根据容量和元素大小相乘，如果新的切片发生了内存溢出或者请求内存大于上限则会直接panic。 如果期望容量大于当前容量的两倍就会使用期望容量； 当原切片容量 \u0026lt; threshold 的时候，新切片容量变成原来的 2 倍； 当原切片容量 \u0026gt; threshold 的时候，进入一个循环，每次容量增加(旧容量+threshold*3) / 4； # 切片拷贝 在Go中使用copy关键字进行切片的复制，实际上底层使用的是对内存的复制。\nGo对切片仅支持append和copy两种操作，需要注意的是在大切片中进行这两种操作会比较消耗资源。\n# 案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func func1(a []int) { b := make([][]int, 0) for i := 0; i \u0026lt; 10; i++ { t := append(a, i) b = append(b, t) } } // 需要理解到append的底层实现： 1. 判断原切片是否要扩容 2. 如果要扩容，先new一个新的数组，再copy值到新的数组；如果不需要扩容。直接追加元素 3. append操作实际上会生成一个slice结构体，如果赋值回去，原始切片会增加len；如果不赋值回去，则len不变。 func func2() { a := [...]int{0, 1, 2, 3} x := a[:1] // { pointer:-\u0026gt;a len:1 cap: 4} y := a[2:] x = append(x, y...) x = append(x, y...) fmt.Println(a, x) } //需要理解到[:]运算的本质 //实际上是创建一个切片的引用，底层数组还是指向原来切片，但len和cap发生变化。具体看是如何切割。 ","date":"2024-03-29T16:40:30+08:00","permalink":"https://bitfrost7.github.io/p/golang/slice/","title":"Golang学习-数组和切片"},{"content":" # 关键字 Go共有25个保留关键字\n# 包管理（2个）： # import 用于导入包，这样就可以使用包中被导出的标识符。导入格式如下：\n1 2 3 4 import \u0026#34;fmt\u0026#34; //直接import import f \u0026#34;fmt\u0026#34; //添加包别名 import . \u0026#34;fmt\u0026#34; //代表导入包，使用时不用加包名 import _ \u0026#34;fmt\u0026#34; //不使用包中的标识符，只需要包的副作用（init函数，包级变量...） # package 用于声明包的名称，需放在go文件所有代码的最前面。一个包由一个或多个go源文件组成，需放在同一个目录下，且同一个目录下的这些go文件的package的名字只能有一个，且不能为\u0026quot;_\u0026quot;。 package \u0026lt;packagename\u0026gt;\n# 程序实体声明与定义（8个）： # chan 用于声明channel(信道)。信道提供一种机制使两个并发执行的函数实现同步，并通过传递具体元素类型的值来通信。\n1 2 3 chan T // 可以被用来发送和接收类型T的值 chan\u0026lt;- T // 只能被用来发送浮点数 \u0026lt;-chan T // 只能被用来接收整数 # const 用于定义常量，一旦创建，不可赋值修改\n# func func 用于定义函数。Go函数支持可变参数且返回值支持多个，但不支持默认参数。如果函数存在多个返回值形参则需要使用小括号括起来，定义格式如下：\n1 2 3 func funcName(){} //无参无返回值 func funcName(t T) T {} //有参有返回值 func funcName(t T, list ...T) (T1,T1) {} //有变参有多个返回值 # interface interface 用于定义接口。一个接口是一个方法集，如果一个类型实现了一个接口中的所有方法集，那么说明该类型实现此接口。接口类型变量可以存储任何实现了该接口的类型的值。特别的，interface{}表示空接口类型，默认地，所有类型均实现了空接口，所以interface{}可以接收任意类型值。\n# map map 用于声明映射变量。映射属容器类类型，是一个同种类型元素的无序组，通过唯一的键可以获取对应的值。可以使用 make 创建 map 变量，在定义 map 时可以省略容量，超出容量时会自动扩容，但尽量提供一个合理的初始值。未初始化的值为 nil。\n# struct struct 用于定义结构体。结构体属容器类型，是多个相同或不同类型值的集合 。一个结构体的零值是类型集合中所有类型的零值。\n# type type 用于定义类型，比如定义 struct、interface、func 与等价类型。\n# var var 用于申明函数级变量和包级变量。\n# 程序流程控制（15个）： # 循环 for 是 Go 中唯一用于循环结构的关键词, 有三种使用方式：1. 单条件 2. 循环变量 3 range\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // for 单条件用法 相当于while i := 0 for i \u0026lt; 10 { fmt.Println(i) i++ } // for 循环变量 for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } // for range 用法 s := []int{1, 2, 3} for i, v := range s { fmt.Println(i, v) } break continue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // break 跳出本次循环 for i := 0; i \u0026lt; 10; i++ { if i == 5 { break } fmt.Println(i) } // continue 跳过本次循环 for i := 0; i \u0026lt; 10; i++ { if i == 5 { continue } fmt.Println(i) } # 条件语句 if else else if 1 2 3 4 5 6 7 if i == 1 { fmt.Println(\u0026#34;i == 1\u0026#34;) } else if i == 2 { fmt.Println(\u0026#34;i == 2\u0026#34;) } else { fmt.Println(\u0026#34;i != 1 \u0026amp;\u0026amp; i != 2\u0026#34;) } switch default case\n1 2 3 4 5 6 7 8 switch i { case 1: fmt.Println(\u0026#34;i == 1\u0026#34;) case 2: fmt.Println(\u0026#34;i == 2\u0026#34;) default: fmt.Println(\u0026#34;i != 1 \u0026amp;\u0026amp; i != 2\u0026#34;) } # 跳转控制 return Go中一个函数可以有一个或者多个返回值，返回值通过return指定。\nreturn关键字中指定了参数时，返回值可以不用名称。如果return省略参数，则返回值部分必须带名称，当返回值带有名称时，必须使用()包起来 在一个函数块里，任何在return之后的代码都不会执行 defer goto # 并发控制 go select ","date":"2024-03-29T15:54:28+08:00","permalink":"https://bitfrost7.github.io/p/golang/","title":"Golang学习-关键字"}]