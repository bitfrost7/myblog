[{"content":"索引介绍 索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针。 使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。 索引虽然能起到加速查询的作用，但是也要认识到加索引会导致DML的速度变慢。\n索引的类别 索引的实现原理 使用索引 创建索引 索引优化 ","date":"2025-09-19T14:17:29+08:00","permalink":"https://bitfrost7.git.io/p/mysql/","title":"MySql学习-索引"},{"content":"DNS协议 什么是DNS协议？ 域名体系 域名层级 域名服务器划分 DNS解析流程 DNS报文格式 基于DNS的网络攻击 DNS劫持 DNS污染 HTTPDNS ","date":"2024-04-18T16:45:14+08:00","permalink":"https://bitfrost7.git.io/p/network/dns/","title":"计算机网络-DNS协议"},{"content":"HTTP协议 什么是HTTP？ 持续连接 非持续连接 HTTP报文格式 请求报文 请求行 请求头 响应报文 状态行和状态码 首部行 HTTP发展 HTTPS加密 Cookie和Session WEB缓存代理和HTTP网关 基于HTTP补充的协议 HTTP网络攻击 ","date":"2024-04-18T14:50:50+08:00","permalink":"https://bitfrost7.git.io/p/network/http/","title":"计算机网络-HTTP协议"},{"content":"计算机网络 计算机网络（Computer Network）是指将多台计算机和其他网络设备连接起来，使它们能够相互通信和共享资源的系统。\n什么是Internet？ 因特网是一个世界范围的计算机网络，它是一个互联了遍及全世界数十亿计算设备的网络，可以说是世界上最大的一个计算机网络。\n端系统\n通常将和Internet相连的这些主机，叫做端系统（End System），可能是一台PC，也可能是一部手机，也可能是一台服务器。端系统分为两类：客户 (client)和服务器(server)。\n客户端一般是使用互联网服务的用户，而服务器通常是提供服务的机器，通常性能更为强大，部署在数据中心IDC（data center）， 数据中心往往有着更为复杂的网络架构。 路由器\n路由器（Routers）是Internet的核心组件，负责在网络间转发数据包。通俗的来讲，路由器就像高速公路上的路牌，指示了车辆该往哪个方向走。 路由器依据数据包的IP地址和路由表决定数据包的最佳路径，并在不同网络之间执行数据包交换。 交换机\n交换机（Switch）是计算机网络中用于连接多台计算机和其他网络设备的网络设备，负责在局域网（LAN）中实现数据包的转发和交换，从而实现设备之间的通信。 可以将交换机理解为就像环线路口连接了多条道路，任一驶入路口的车辆能根据自己的目的地选择出口，交换机也连接了多台计算机和网络设备，可以选择性地将数据包转发到特定的端口完成通信。 ISP\nISP指的是互联网服务提供商（Internet Service Provider），是指向个人、家庭、企业等提供互联网接入服务的公司或组织。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。 ISP分为地区ISP，在某一个城市提供接入服务；国家级ISP，比如中国联通；全球ISP，在全球范围内提供互联网接入服务的大型ISP，例如AT\u0026amp;T。 无论那种ISP都是一个独立的网络，较高级ISP都是通过高速光纤链路互联起来。 协议\n想象一下，当你和朋友聊天时，你们会遵循一定的语言规则（比如英语或中文的语法规则），确定谁先说话、说什么内容、怎样说才能确保对方理解。在网络世界中，设备之间的沟通同样需要这样的规则。 所谓协议，其实就是一系列规定好的语法，语义，时序，按照这样的规则，让通信双方都能理解。网络协议 (protocol) 定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。 因特网标准和RFC文档 对于互联网通信，一个规范且通用的协议十分重要，因特网工程任务组(Internet Engineering Task Force, IETF )制定了一系列通信标准，并且这个标准也开放在互联网上，被称为 请求评论（Request For Comment, RFC）。 例如RFC 894 定义了如何在以太网帧格式上封装IP数据报。 Internet是怎么工作的？ 接入网 核心网 分组交换 电路交换 分层网络体系 应用模型 应用层 运输层 网络层 链路层 物理层 OSI模型 封装，分组，卸载，组装 Internet发展和前景 历史 网络攻击 前景 ","date":"2024-04-18T10:34:34+08:00","permalink":"https://bitfrost7.git.io/p/network/introduction/","title":"计算机网络-简介"},{"content":"Zap介绍 zap 是 uber 开源的一个高性能，结构化，分级记录的日志记录包。\n特性 高性能：zap 对日志输出进行了多项优化以提高它的性能 日志分级：有 Debug，Info，Warn，Error，DPanic，Panic，Fatal 等 日志记录结构化：日志内容记录是结构化的，比如 json 格式输出 自定义格式：用户可以自定义输出的日志格式 自定义公共字段：用户可以自定义公共字段，大家输出的日志内容就共同拥有了这些字段 调试：可以打印文件名、函数名、行号、日志时间等，便于调试程序 自定义调用栈级别：可以根据日志级别输出它的调用栈信息 Namespace：日志命名空间。定义命名空间后，所有日志内容就在这个命名空间下。命名空间相当于一个文件夹 支持 hook 操作 安装 1 go get -u go.uber.org/zap 使用 ","date":"2024-04-15T13:57:43+08:00","permalink":"https://bitfrost7.git.io/p/golang/libs/zap/","title":"Golang学习-zap日志库"},{"content":"源码解读 main函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cmdline.h\u0026gt; #include \u0026lt;cmdline_socket.h\u0026gt; #include \u0026lt;rte_debug.h\u0026gt; #include \u0026lt;rte_eal.h\u0026gt; #include \u0026#34;commands.h\u0026#34; int main(int argc, char **argv) { int ret; struct cmdline *cl; ret = rte_eal_init(argc, argv); if (ret \u0026lt; 0) rte_panic(\u0026#34;init EAL fail\\n\u0026#34;); cl = cmdline_stdin_new(main_ctx, \u0026#34;my cmd\u0026gt;\u0026#34;); if (cl == NULL) rte_panic(\u0026#34;init cmd fail\\n\u0026#34;); cmdline_interact(cl); cmdline_stdin_exit(cl); rte_eal_cleanup(); } main函数分为三部分：\n第一部分是EAL初始化，涉及dpdk环境的初始化，如果初始化成功，会返回ret，ret为启动命令中传递给dpdk的参数个数。如果argc-=ret 就是将命令行参数个数减去dpdk使用的参数，argv+=ret就是将参数数组指针向后移动。\n第二部分为cmdline的初始化、交互、以及退出。 第三部分为EAL的清理。\ncmdline_stdin_new函数 源码： /lib/cmdline/cmdline_socket.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct cmdline * cmdline_stdin_new(cmdline_parse_ctx_t *ctx, const char *prompt) { struct cmdline *cl; cl = cmdline_new(ctx, prompt, 0, 1); if (cl != NULL) terminal_adjust(cl); return cl; } struct cmdline * cmdline_new(cmdline_parse_ctx_t *ctx, const char *prompt, int s_in, int s_out) { struct cmdline *cl; int ret; if (!ctx || !prompt) return NULL; cl = malloc(sizeof(struct cmdline)); if (cl == NULL) return NULL; memset(cl, 0, sizeof(struct cmdline)); cl-\u0026gt;s_in = s_in; cl-\u0026gt;s_out = s_out; cl-\u0026gt;ctx = ctx; ret = rdline_init(\u0026amp;cl-\u0026gt;rdl, cmdline_write_char, cmdline_valid_buffer, cmdline_complete_buffer, cl); if (ret != 0) { free(cl); return NULL; } cmdline_set_prompt(cl, prompt); rdline_newline(\u0026amp;cl-\u0026gt;rdl, cl-\u0026gt;prompt); return cl; } 可以看出来cmdline_stdin_new底层调用的cmdline_new。\ncmdline_new函数主要做了以下几件事：\n分配一个新的cmdline结构体 设置IO以及解析器上下文ctx 初始化rdline，提供一个输出缓冲区，验证缓冲区和自动完成功能，具体暂不深入 设置提示词prompt 设置rdline，暂不深入。 总的来说，此函数就是初始化一个cmdline提供使用，我们需要关心的其实是cmdline_parse_ctx_t的设置。 cmdline_parse_ctx_t 源码：/lib/cmdline/cmdline_parse.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct。cmdline_inst { /* f(parsed_struct, data) */ void (*f)(void *, struct cmdline *, void *); void *data; const char *help_str; cmdline_parse_token_hdr_t *tokens[]; }; /** * A context is identified by its name, and contains a list of * instruction */ typedef struct cmdline_inst cmdline_parse_inst_t; typedef cmdline_parse_inst_t *cmdline_parse_ctx_t; cmdline_parse_inst_t 和 cmdline_parse_ctx_t 互为别名，这里引入上下文的概念是为了存储一组相关的指令。\ncmdline_inst结构体有四个字段，第一个成员为一个回调函数，当cmdline解析到参数时调用，第二个参数暂时不用关心，第三个参数是帮助信息，第四个参数是解析器。\n总结 cmdline是dpdk提供的一个创建命令行程序的工具。相关的头文件有：\ncmdline.h：负责定义命令行程序相关api，创建、使用、释放。。。 cmdline_socket.h：定义一些常用的io，比方说stdin，终端输入，file，文件输入 cmdline_parse.h: 定义命令行解析相关api cmdline_parse_string.h，cmdline_parse_num.h，cmdline_parse_ipaddr.h：都是命令行解析器，分别负责解析 字符串，数字，ip地址 cmdline_rdline.h：定义了一个命令行读取器，能从标准输入中读取字符并进行处理，能添加命令行历史记录。 cmdline.h cmdline：核心结构体，代表一个命令行对象； rdline_status：枚举类型，定义了命令行的状态：初始化，运行，退出 cmdline_new： 创建一个命令行程序； cmdline_set_prompt：设置命令行的提示符； cmdline_free：释放命令行对象； cmdline_printf：在命令行对象上打印格式化的字符串； cmdline_in：将输入的字符串发送到命令行对象进行处理； cmdline_write_char：向命令行对象写入单个字符； cmdline_interact: 与命令行对象进行交互； cmdline_quit: 退出命令行交互； cmdline_socket.h cmdline_file_new：创建一个文件输入的命令行程序 cmdline_stdin_new：创建一个标准输入的命令行程序, 实际上底层调的也是cmdline_new 1 2 3 4 5 6 7 8 9 struct cmdline * cmdline_stdin_new(cmdline_parse_ctx_t *ctx, const char *prompt) { struct cmdline *cl; cl = cmdline_new(ctx, prompt, 0, 1); if (cl != NULL) terminal_adjust(cl); return cl; } cmdline_stdin_exit：释放一个标准输入的命令行程序 cmdline_parse.h cmdline_parse_ctx_t： 命令行参数解析器的上下文，存储着解析器的配置。cmdline_inst是cmdline_inst的别名。 1 2 3 4 5 6 7 struct cmdline_inst { /* f(parsed_struct, data) */ void (*f)(void *, struct cmdline *, void *); // 解析函数，第一个参数是解析结果，第二个参数是cmdline，第三个是输入 void *data; const char *help_str; // 帮助信息字符串 cmdline_parse_token_hdr_t *tokens[]; // tokens列表 }; ","date":"2024-04-04T00:00:00Z","permalink":"https://bitfrost7.git.io/p/network/dpdk/03/","title":"dpdk学习03-cmdline源码解读"},{"content":"dpdk开发 dpdk是一个提供了一个高性能网络框架，开发者可以在此基础上构建自己的网络应用程序，同时拥有接近硬件满速的性能。\ndpdk框架主要组件有：\n环境适配层 EAL(Environment Abstraction Layer)\n该组件通过提供了通用接口提供一些核心服务：\n1. DPDK的加载和启动\n2. 多线程和多进程执行方式\n3. CPU亲和性设置\n4. 系统内存分配和释放\n5. 原子操作\n6. 定时器\n7. PCI总线访问 8. \u0026hellip;\u0026hellip; 环形缓冲区(rte_ring) 该组件提供了一个无锁的环形队列数据结构，支持多生产者，多消费者。ring主要用于不同核之间或是逻辑核上处理单元之间的通信。 内存池管理（rte_mempool） 该组件主要职责就是在内存中分配指定数目对象的POOL。每个POOL以名称来唯一标识，并且使用一个ring来存储空闲的对象节点。 网络报文缓冲区(rte_mbuf) 报文缓存组件提供了创建、释放报文缓存的能力，DPDK应用程序中使用这些报文缓存来存储消息。 定时器(rte_timer) 该组件提供了定时服务，为函数异步执行提供支持，并且能在每个核上根据需要初始化。 除此之外，dpdk还提供了哈希（hash），最长前缀匹配的（lpm）算法库，以及ip协议相关的网络库等。 所有的dpdk api都能在官方文档中找到，多熟悉即可。\nHelloWorld 以下是官方自带的helloworld代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/queue.h\u0026gt; #include \u0026lt;rte_memory.h\u0026gt; #include \u0026lt;rte_launch.h\u0026gt; #include \u0026lt;rte_eal.h\u0026gt; #include \u0026lt;rte_per_lcore.h\u0026gt; #include \u0026lt;rte_lcore.h\u0026gt; #include \u0026lt;rte_debug.h\u0026gt; static int lcore_hello(__attribute__((unused)) void *arg) { unsigned lcore_id; lcore_id = rte_lcore_id(); printf(\u0026#34;hello from core %u\\n\u0026#34;, lcore_id); return 0; } int main(int argc, char **argv) { int ret; unsigned lcore_id; // 1. 初始化环境抽象层（EAL） ret = rte_eal_init(argc, argv); if (ret \u0026lt; 0) rte_panic(\u0026#34;Cannot init EAL\\n\u0026#34;); /* call lcore_hello() on every slave lcore */ // 2. 在每个可用的lcore上调用lcore_hello RTE_LCORE_FOREACH_WORKER(lcore_id) { rte_eal_remote_launch(lcore_hello, NULL, lcore_id); } /* call it on master lcore too */ lcore_hello(NULL); rte_eal_mp_wait_lcore(); return 0; } 代码中关键在于：\nrte_eal_init(); 这个函数初始化dpdk EAL环境抽象层，必须存在的函数。 RTE_LCORE_FOREACH_SLAVE(); 实际上是一个for循环的宏，遍历所有的可用slave核，需要传入一个循环变量lcore_id。 rte_eal_remote_launch(); 这个函数实际上就是让指定的slave核去执行函数，有些类似Golang中的go关键字。 第一个参数是f，执行的函数，这个函数接受一个void* 指针，返回一个int，第二个参数是void *，是回调函数的参数，第三个参数是运行函数的逻辑核id。 rte_eal_mp_wait_lcore(); 这个函数实际上就是等待所有核上的任务执行完成。类似go中的waitgroup。 整体代码执行的话，使用gcc 手动链接比较麻烦，直接使用官方给的示例MakeFile即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # SPDX-License-Identifier: BSD-3-Clause # Copyright(c) 2010-2014 Intel Corporation # binary name APP = helloworld # all source are stored in SRCS-y SRCS-y := main.c PKGCONF ?= pkg-config # Build using pkg-config variables if possible ifneq ($(shell $(PKGCONF) --exists libdpdk \u0026amp;\u0026amp; echo 0),0) $(error \u0026#34;no installation of DPDK found\u0026#34;) endif all: shared .PHONY: shared static shared: build/$(APP)-shared ln -sf $(APP)-shared build/$(APP) static: build/$(APP)-static ln -sf $(APP)-static build/$(APP) PC_FILE := $(shell $(PKGCONF) --path libdpdk 2\u0026gt;/dev/null) CFLAGS += -O3 $(shell $(PKGCONF) --cflags libdpdk) LDFLAGS_SHARED = $(shell $(PKGCONF) --libs libdpdk) LDFLAGS_STATIC = $(shell $(PKGCONF) --static --libs libdpdk) ifeq ($(MAKECMDGOALS),static) # check for broken pkg-config ifeq ($(shell echo $(LDFLAGS_STATIC) | grep \u0026#39;whole-archive.*l:lib.*no-whole-archive\u0026#39;),) $(warning \u0026#34;pkg-config output list does not contain drivers between \u0026#39;whole-archive\u0026#39;/\u0026#39;no-whole-archive\u0026#39; flags.\u0026#34;) $(error \u0026#34;Cannot generate statically-linked binaries with this version of pkg-config\u0026#34;) endif endif CFLAGS += -DALLOW_EXPERIMENTAL_API build/$(APP)-shared: $(SRCS-y) Makefile $(PC_FILE) | build $(CC) $(CFLAGS) $(SRCS-y) -o $@ $(LDFLAGS) $(LDFLAGS_SHARED) build/$(APP)-static: $(SRCS-y) Makefile $(PC_FILE) | build $(CC) $(CFLAGS) $(SRCS-y) -o $@ $(LDFLAGS) $(LDFLAGS_STATIC) build: @mkdir -p $@ .PHONY: clean clean: rm -f build/$(APP) build/$(APP)-static build/$(APP)-shared test -d build \u0026amp;\u0026amp; rmdir -p build || true 开发环境搭建 clion+远程运行\n","date":"2024-04-03T00:00:00Z","permalink":"https://bitfrost7.git.io/p/network/dpdk/02/","title":"dpdk学习02-运行helloworld"},{"content":"上下文Context 什么是context？ Go 1.7 版本引入了context.Context 接口，主要用于处理涉及多个 goroutine间的协作、取消信号传递、超时控制以及携带数据。\ncontext.Context 可以看作是一个封装了任务执行环境的对象，可以理解为协程间的执行上下文。它允许在整个协程树中传播这些上下文，并且提供了一种并发安全的方式来通知所有相关的goroutine 应该尽早结束其任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // context 接口定义 type Context interface { // Deadline()返回一个完成工作的截止时间，表示上下文应该被取消的时间。 // 如果 `ok==false` 表示没有设置截止时间。 Deadline() (deadline time.Time, ok bool) // Done()返回一个 Channel，这个 Channel 会在当前工作完成时被关闭，表示上下文应该被取消。 // 如果无法取消此上下文，则 Done 可能返回 nil。多次调用 Done 方法会返回同一个 Channel。 Done() \u0026lt;-chan struct{} // Err()返回Context结束的原因，它只会在Done方法对应的Channel关闭时返回非空值。 // 如果Context被取消，会返回context.Canceled错误； // 如果Context超时，会返回context.DeadlineExceeded错误。 Err() error // Value()从Context中获取键对应的值。 // 如果未设置key对应的值则返回nil。以相同key多次调用会返回相同的结果。 Value(key interface{}) interface{} } context使用 context的最大用处就是用做协程间信号同步。\n以常见的api服务为例，每一个请求都是由一个goroutine处理，而每个处理协程可能都会启动新的子协程来辅助处理任务，这就构成一个goroutine树。而 context 的作用就是在不同 goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。 在具体使用的时候，context包提供了四种With函数来派生出我们需要的上下文：\n1 2 3 4 5 6 7 8 9 10 11 // WithCancel 返回一个带有终止控制的context func WithCancel(parent Context) (ctx Context, cancel CancelFunc) // WithDeadline 返回一个带有定时器的context，也带有终止控制 func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) // WithTimeout 返回一个带有超时控制的context，也带有终止控制 func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) // WithValue 返回一个带有参数的context func WithValue(parent Context, key, val interface{}) Context 通常我们先创建一个空context，再由此派生出我们需要的context，就创建出来了一颗context树。 在context的派生关系中：\n当父context取消时，子context也都会被取消； 当父context设置参数时，子context也能读取到这个参数，但key只能被设置一次，不能被修改。 默认上下文 context包主要提供了两种创建默认context的方式：\n1 2 context.Backgroud() context.TODO() 这两个函数其实只是互为别名，没有差别，官方给的定义是：\ncontext.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来； context.TODO 应该只在不确定应该使用哪种上下文时使用； 在大多数情况下，我们都使用context.Background作为起始的上下文向下传递。 从源码中我们可以看到，这两个context都是返回了一个emptyCtx的指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type emptyCtx struct{} func (emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (emptyCtx) Done() \u0026lt;-chan struct{} { return nil } func (emptyCtx) Err() error { return nil } func (emptyCtx) Value(key any) any { return nil } 实际上emptyCtx实现的都是空方法，没有任何功能。\n取消信号 WithCancel方法可以从一个context中衍生出一个新的子上下文，并且提供一个取消函数，当这个取消函数被调用时，当前上下文以及它的子上下文都会被取消，所有的 goroutine 都会同步收到这一取消信号。\n1 2 3 4 5 6 7 8 9 10 11 12 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := withCancel(parent) return c, func() { c.cancel(true, Canceled, nil) } } func withCancel(parent Context) *cancelCtx { if parent == nil { panic(\u0026#34;cannot create context from nil parent\u0026#34;) } c := \u0026amp;cancelCtx{} c.propagateCancel(parent, c) //构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消 return c } 当cancelFunc被调用时：\n会先关闭Done，同步关闭信号 调用持有的所有子context的cancelFunc 从父context移除自己，删掉父context持有的自己的cancelFunc 以下是部分源码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func (c *cancelCtx) cancel(removeFromParent bool, err, cause error) { ... // close done channel d, _ := c.done.Load().(chan struct{}) if d == nil { c.done.Store(closedchan) } else { close(d) } // 关闭所有子context for child := range c.children { // NOTE: acquiring the child\u0026#39;s lock while holding parent\u0026#39;s lock. child.cancel(false, err, cause) } // 从父context移除自己 if removeFromParent { removeChild(c.Context, c) } } 除了 context.WithCancel 之外，context 包中的另外两个函数 WithDeadline 和 WithTimeout 也都能创建可以被取消的计时器上下文。\n1 2 3 4 // WithTimeout函数底层也是通过WithDeadline实现，只是deadline设置为now+timeout。 func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } WithDeadline 的主要逻辑是：\n判断了父上下文的截止日期与当前日期 和父上下文进行关联 通过 time.AfterFunc 创建定时器 当时间超过了截止日期后会调用 cancel 同步取消信号 传值上下文 context 包提供了一个WithValue方法，能从父上下文中创建一个子上下文，并且能够存储一个kv对。返回一个valueCtx结构体：\n1 2 3 4 type valueCtx struct { Context key, val any } valueCtx结构体会将除了 Value 之外的 Err、Deadline 等方法代理到父上下文中，它只会响应 Value 方法。\n当通过Value方法获取某个key时，如果和自己存储的kv对不存在，则会到父上下文去寻找。\n总结 自从go1.7引入了context包，context几乎成了协程间之间同步取消信号和上下文信息传递的标准做法，实践上，经常应用于像TraceId，公共参数，鉴权校验，接口超时等场景，都会使用context作为媒介。\n","date":"2024-04-02T17:32:17+08:00","permalink":"https://bitfrost7.git.io/p/golang/context/","title":"Golang学习-上下文context"},{"content":"dpdk安装 环境：Mac m1，Vmware Fusion 虚拟机，Ubuntu 20.04\n版本：dpdk 22.11.4\n因为ubuntu已经有了dpdk的二进制源，直接安装即可，如果需要二进制安装，可参考官方文档：\n1 apt install -yq dpdk dpdk-dev dpdk-doc gcc g++ 配置环境 dpdk环境最好配置2张网卡，一个选择桥接，用来配置dpdk开发，一个选择NAT，用来和宿主机连接。cpu选择4核，内存选择8G，按宿主机资源即可。 启动dpdk环境需要3步：\n安装uio启动 将网卡和dpdk绑定 设置内存大页 安装驱动 dpdk一般多采用两种驱动：vfio-pci和igb_uio。\nvfio-pci:\n1 2 3 4 sudo modprobe vfio \u0026amp;\u0026amp; \\ sudo modprobe vfio-pci # 配置noiommu_mode。 sudo bash -c \u0026#39;echo 1 \u0026gt; /sys/module/vfio/parameters/enable_unsafe_noiommu_mode\u0026#39; igb_uio:\n1 git clone https://dpdk.org/git/dpdk-kmods 下载以后make安装即可\n1 2 3 4 pushd dpdk-kmods/linux/igb_uio sudo make sudo depmod \u0026amp;\u0026amp; sudo insmod igb_uio.ko popd 或者直接apt install dpdk-kmods-dkms\n绑定网卡 使用dpdk安装自带了工具`dpdk-devbind.py直接配置：\n1 2 dpdk-devbind.py -s # 查看网卡绑定状态 dpdk-devbind.py -b vfio-pci 0000:03:00.0 # 将0000:03:00.0网卡绑到vfio-pci驱动 设置hugepage x86架构CPU支持2M和1G大小的pagesize，一般linux默认配置了2M的大小，通过cat /proc/meminfo|grep -i huge来查看。\n1 2 3 4 5 6 # 挂载1G的hugepage sudo mkdir /mnt/huge sudo mount -t hugetlbfs -o pagesize=1G none /mnt/huge # 设置巨页数量 以下都是在numa节点0上设置 如果设置其他节点可修改路径 sudo bash -c \u0026#39;echo 2 \u0026gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages\u0026#39; sudo bash -c \u0026#39;echo 1024 \u0026gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages\u0026#39; 方便起见，写一个init脚本，方便快速拉起dpdk环境：\n1 2 3 4 5 6 7 8 modprobe vfio modprobe vfio-pci echo 1 \u0026gt; /sys/module/vfio/parameters/enable_unsafe_noiommu_mode dpdk-devbind.py -b vfio-pci 0000:03:00.0 dpdk-devbind.py -b vfio-pci 0000:1a:00.0 mount -t hugetlbfs -o pagesize=1G none /mnt/huge echo 2 \u0026gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages echo 1024 \u0026gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages 第一个测试程序 测试程序使用dpdk官方提供的testpmd，测试dpdk网卡绑定 。\n测试环境： 两台虚拟机，要求都已经安装了dpdk的环境。\n安装pktgen 1 2 3 4 5 6 7 git clone git://dpdk.org/apps/pktgen-dpdk cd pktgen-dpdk/ meson build cd build ninja # app/pktgen 编译出的程序 mv app/pktgen /usr/local/bin 开始测试 node1 node2 mac信息\n1 2 3 4 5 6 node1 绑定接口名称: ens161, MAC地址: 00:0c:29:a5:21:1e, IP地址: 未分配 绑定接口名称: ens256, MAC地址: 00:0c:29:a5:21:14, IP地址: 未分配 node2 绑定接口名称: ens161, MAC地址: 00:0c:29:57:f0:2f, IP地址: 未分配 绑定接口名称: ens256, MAC地址: 00:0c:29:57:f0:25, IP地址: 未分配 在node1 上运行testpmd： 1 dpdk-testpmd -l 0-1 -n 1 -- -i 将网卡设为只读模式、非混杂模式(这样就只收pktgen发来的包)后开始收包 1 2 3 4 set fwd rxonly set promisc all off show port stats all start 在node2 运行pktgen 进行发包 1 pktgen -l 0-1 -n 3 -- -P -m \u0026#34;[1].0\u0026#34; 设置目的mac，发送100个包 1 2 3 set 0 dst mac 00:0c:29:a5:21:1e set 0 count 100 start 0 在node1上执行 show port stats all,此时可以发现其中一张网卡多了6400，pktgen发包默认大小64字节。 执行quit退出 测试符合预期，环境搭建完成。\n","date":"2024-04-02T00:00:00Z","permalink":"https://bitfrost7.git.io/p/network/dpdk/01/","title":"dpdk学习01—环境搭建"},{"content":"认识dpdk 什么是dpdk？ dpdk是intel开源的一个网络加速工具包，目的是在IA平台上解决高性能网络数据包处理的问题。\n传统网络包处理的过程是：\n网卡收到数据包 网卡将帧DMA到内存 网卡发送硬中断 cpu响应中断，调用对应函数进行收包 将ring buffer保存到skb 内核协议栈处理帧 用户进程处理报文 因为传统网络包处理是中断驱动的，所以在大量网络请求下会出现irq风暴，降低处理性能。除此之外还涉及到多次用户态和内核态数据拷贝，降低性能。当时流行的做法是通过硬件来加速网络包处理，但是dpdk的产生证明了通用化硬件在软件极致优化的情况下也能做到达到io的极限。 基于IA处理器的DPDK技术，很好地解决高性能数据包处理的问题，这些技术包括：\n通过轮询来处理数据包，避免中断上下文切换的开销 使用用户态驱动，避免内核态到用户态不必要的内存拷贝和系统调用 设置cpu亲和性与独占，避免线程在不同核心间频繁切换; 限制某些核心不参与Linux系统调试, 可使线程独占该核心 利用大页内存降低TLB miss dpdk框架的由来 由于传统包处理任务存在内核态与用户态的切换，以及多次的内存拷贝，系统消耗变大，以CPU为核心的系统存在很大的处理瓶颈。为了提升在通用服务器（COTS）的数据包处理效能，Intel推出了服务于IA（Intel Architecture）系统的DPDK技术。\nDPDK是Data Plane Development Kit的缩写。简单说，DPDK应用程序运行在操作系统的User Space，利用自身提供的数据面库进行收发包处理，绕过了Linux内核态协议栈，以提升报文处理效率。\ndpdk的优势和现状 零拷贝架构 轮询模式 vs 中断模式 NUMA感知的内存管理 dpdk的核心组件 EAL 环境抽象层，EAL是DPDK的基石，提供硬件和操作系统的抽象。完成以下工作： rte_memory，内存管理（大页、NUMA） rte_pci，rte_bus。PCIe 设备发现和绑定 rte_lcore，核心和拓扑发现 rte_timer，定时器和告警设置 内存管理组件，高性能数据包处理的内存基础设施： Mbuf（内存缓冲区）：数据包的核心容器，支持链式存储、零拷贝、硬件卸载元数据 Mempool（内存池）：预分配的对象池，消除运行时内存分配开销 内存分配器：NUMA 感知的内存分配，支持对齐分配 网络设备组件，用户态网络驱动和硬件抽象： PMD（轮询模式驱动）：绕过内核，直接操作网卡硬件 设备管理 API：端口配置、队列管理、统计收集 Flow API（流分类）：硬件加速的流规则匹配和动作执行 无锁数据结构，多核心并行处理的同步原语： Ring（环形队列）：无锁生产者-消费者队列，支持批量操作 Hash（哈希表）：无锁哈希表，用于路由表、会话表 其他结构：栈、布隆过滤器、LPM（最长前缀匹配） 定时调度，高性能的事件和定时管理： 定时器系统：纳秒精度定时器，支持单次和周期性任务 事件驱动框架（Eventdev）：任务调度、负载均衡、优先级队列 工作队列：任务分发和执行框架 还有安全加密，QoS控制等组件，后续文章再说 相关术语介绍 ACL：Access Control List，访问控制列表，是路由器和交换机接口的指令列表，用来控制端口进出的数据包；简而言之就是用来控制数据流。 SSL：Secure Sockets Layer，安全套接层，是为网络通信提供安全及数据完整性的一种安全协议，在传输层对网络连接进行加密。 RSS：Receive Side Scaling，是一种能够在多处理器系统下使接收报文在多个CPU之间高效分发的网卡驱动技术。 NUMA：Non Uniform Memory Access Architecture，非统一内存访问架构； QOS：Quality of Service，服务质量，指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力, 是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。 NIC：Network Interface Card，网卡，网卡是局域网中最基本的部件之一，它是连接计算机与网络的硬件设备。 PCI：Peripheral Component Interconnect，计算机一种标准总线，NIC就是使用的这种总线方式。 PMD：Poll Mode Drive，轮询模式驱动，DPDK就是采用的这种模式。 RTE：Run Time Environment，通过PMD实现快速分组处理数据的一个框架。 MPLS：Multi-Protocol Label Switching，多协议标签交换，是一种用于快速数据包交换和路由的体系，它为网络数据流量提供了目标、路由地址、转发和交换等能力。更特殊的是，它具有管理各种不同形式通信流的机制。 前置C语言语法 必须理解的C语言技巧 容器宏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 获取结构体成员的偏移量 #define offsetof(TYPE, MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) // 通过成员指针获取包含它的结构体指针（DPDK核心技巧！） #define container_of(ptr, type, member) ({ \\ const typeof(((type *)0)-\u0026gt;member) *__mptr = (ptr); \\ (type *)((char *)__mptr - offsetof(type, member)); }) // 使用示例： struct my_struct { int value; struct rte_mbuf mbuf; // 内嵌成员 }; // 已知 mbuf 指针，找到包含它的 my_struct struct rte_mbuf *mbuf_ptr = ...; struct my_struct *parent = container_of(mbuf_ptr, struct my_struct, mbuf); 分支预测优化 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;rte_branch_prediction.h\u0026gt; // 告诉编译器哪个分支更可能发生 if (likely(x \u0026gt; 0)) { // 这个分支大概率发生 // 快速路径 } else { // 这个分支很少发生 // 慢速路径 } // 实际定义： #define likely(x) __builtin_expect(!!(x), 1) #define unlikely(x) __builtin_expect(!!(x), 0) 位操作宏 1 2 3 4 5 6 7 8 9 10 11 12 13 // 常用位操作 #define RTE_BIT32(pos) (1U \u0026lt;\u0026lt; (pos)) #define RTE_BIT64(pos) (1ULL \u0026lt;\u0026lt; (pos)) // 位域操作 #define RTE_FLAG_SET(var, flag) ((var) |= (flag)) #define RTE_FLAG_CLEAR(var, flag) ((var) \u0026amp;= ~(flag)) #define RTE_FLAG_ISSET(var, flag) (((var) \u0026amp; (flag)) != 0) // 对齐操作 #define RTE_ALIGN_FLOOR(val, align) ((val) \u0026amp; ~((align) - 1)) #define RTE_ALIGN_CEIL(val, align) RTE_ALIGN_FLOOR((val) + (align) - 1, align) #define RTE_ALIGN(val, align) RTE_ALIGN_CEIL(val, align) 内存屏障 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;rte_atomic.h\u0026gt; // 编译器屏障（阻止重排序） #define rte_compiler_barrier() do { asm volatile(\u0026#34;\u0026#34; ::: \u0026#34;memory\u0026#34;); } while(0) // 读写屏障 #define rte_smp_rmb() rte_compiler_barrier() // 读内存屏障 #define rte_smp_wmb() rte_compiler_barrier() // 写内存屏障 #define rte_smp_mb() rte_compiler_barrier() // 全内存屏障 // 使用示例（无锁编程中必须！） producer: data = prepare_data(); rte_smp_wmb(); // 确保数据先写入 flag = 1; // 再设置标志 consumer: while (!flag) ; // 等待标志 rte_smp_rmb(); // 确保先读到标志 use_data(data); // 再使用数据 原子操作 1 2 3 4 5 6 7 8 9 // DPDK 原子操作封装 static inline void rte_atomic16_init(rte_atomic16_t *v, int16_t val); static inline int16_t rte_atomic16_read(const rte_atomic16_t *v); static inline void rte_atomic16_set(rte_atomic16_t *v, int16_t new_value); static inline void rte_atomic16_add(rte_atomic16_t *v, int16_t inc); static inline void rte_atomic16_sub(rte_atomic16_t *v, int16_t dec); static inline int16_t rte_atomic16_add_return(rte_atomic16_t *v, int16_t inc); // 64位版本类似：rte_atomic64_* DPDK里常见编码模式 内联函数模式 1 2 3 4 5 6 7 8 9 10 // DPDK 大量使用 static inline 提升性能 static inline uint16_t rte_eth_rx_burst(uint16_t port_id, uint16_t queue_id, struct rte_mbuf **rx_pkts, const uint16_t nb_pkts) { // 简单封装，可能被编译器内联展开 return (*rte_eth_devices[port_id].rx_pkt_burst) (rte_eth_devices[port_id].data-\u0026gt;rx_queues[queue_id], rx_pkts, nb_pkts); } 函数指针表模式 1 2 3 4 5 6 7 8 9 10 // 驱动架构：通过函数指针实现多态 struct rte_eth_dev_ops { int (*dev_start)(struct rte_eth_dev *dev); void (*dev_stop)(struct rte_eth_dev *dev); int (*dev_configure)(struct rte_eth_dev *dev); // ... 几十个操作函数 }; // 使用时： dev-\u0026gt;dev_ops-\u0026gt;dev_start(dev); 配置结构体模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 零初始化 + 按需设置 struct rte_eth_conf port_conf = { .rxmode = { .mtu = 9000, .max_rx_pkt_len = 9000, }, .txmode = { .offloads = DEV_TX_OFFLOAD_MBUF_FAST_FREE, }, .rx_adv_conf = { .rss_conf = { .rss_key = NULL, .rss_hf = ETH_RSS_IP | ETH_RSS_TCP | ETH_RSS_UDP, }, }, }; 必须知道的头文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 核心头文件 #include \u0026lt;rte_eal.h\u0026gt; // EAL 初始化 #include \u0026lt;rte_mbuf.h\u0026gt; // Mbuf 操作 #include \u0026lt;rte_mempool.h\u0026gt; // 内存池 #include \u0026lt;rte_ethdev.h\u0026gt; // 网卡设备 #include \u0026lt;rte_ring.h\u0026gt; // 无锁队列 #include \u0026lt;rte_hash.h\u0026gt; // 哈希表 #include \u0026lt;rte_lpm.h\u0026gt; // LPM 路由 // 工具头文件 #include \u0026lt;rte_log.h\u0026gt; // 日志系统 #include \u0026lt;rte_debug.h\u0026gt; // 调试宏 #include \u0026lt;rte_common.h\u0026gt; // 通用宏 #include \u0026lt;rte_branch_prediction.h\u0026gt; // 分支预测 #include \u0026lt;rte_malloc.h\u0026gt; // 动态内存 ","date":"2024-04-01T00:00:00Z","permalink":"https://bitfrost7.git.io/p/network/dpdk/00/","title":"dpdk学习00—预备知识"},{"content":"介绍 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。 单例模式有两个特点：\n一个类只有一个实例 该实例只有一个全局访问节点 实现 单例模式的实现需要三个必要的条件：\n单例类的构造函数必须是私有的，这样才能将类的创建权控制在类的内部，从而使得类的外部不能创建类的实例。 单例类通过一个私有的静态变量来存储其唯一实例。 单例类通过提供一个公开的静态方法，使得外部使用者可以访问类的唯一实例。 单例的实现一共有五种方式： 饿汉式（静态初始化） 天生线程安全，效率高 如果实例没有被使用，会造成内存浪费，并且生命周期固定，比方说要求根据配置文件变化，不能重新初始化或替换实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package singleton type Singleton struct { } var instance *Singleton func init() { instance = \u0026amp;Singleton{} } func GetInstance() *Singleton { return instance } 懒汉式 (用时初始化) 线程不安全 1 2 3 4 5 6 7 8 9 10 11 12 13 package singleton type Singleton struct { } var instance *Singleton func GetInstance() *Singleton { if instance == nil { instance = \u0026amp;Singleton{} } return instance } 双重检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package singleton import \u0026#34;sync\u0026#34; type Singleton struct { } var ( instance *Singleton once sync.Once ) func GetInstance() *Singleton { once.Do(func() { instance = \u0026amp;Singleton{} }) return instance } ","date":"2024-03-29T22:24:18+08:00","permalink":"https://bitfrost7.git.io/p/design-patterns/singleton/","title":"设计模式-单例"},{"content":"标准库容器 Go语言中有一个 container 包，提供了三种常用的数据结构：list双向链表，heap堆，ring环\nList 链表是一种常见的数据结构，它由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表的优点是在插入和删除操作时非常高效 O(1)，而在访问时效率较低 O(n)。链表有单向链表、双向链表和循环链表等多种类型，链表还有许多变种，如哈希链表、跳表等。 在Go中cotainer/list 实现了双向链表。 数据结构如下：\n1 2 3 4 5 6 7 8 9 10 type Element struct { next, prev *Element list *List Value any } type List struct { root Element // sentinel list element, only \u0026amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element } 链表头尾节点使用了哨兵节点，方便删除和插入。\nList常用api 名称 函数参数 作用 New 无 new一个list返回 Front 无 返回头节点 Back 无 返回尾节点 Remove element 移除节点 PushFront value any 头部添加元素 PushBack value any 尾部添加元素 InsertBefore value any , mark element 在mark后添加元素 MoveToFront e element 移动节点到头部 PushBackList other *list 将另一个列表添加进去 1 2 3 4 // 遍历一个链表 for e := a.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } Heap Go语言container包中， heap 为所有实现了 heap.Interface 的类型提供了堆操作。\n堆，其实是一个优先级队列，这个队列里按照优先级排，优先级高的在堆顶，优先级低的在堆底。 一个堆是一个完全二叉树，树中不存在气泡，是连续存储的，所以可以直接由数组实现。\nGolang中的堆是最小堆，父节点的值总是小于子节点的值，所以root节点的值最小。\n接口定义 Go中要使用heap，必须实现heap.Interface:\n1 2 3 4 5 type Interface interface { sort.Interface Push(x any) // add x as element Len() Pop() any // remove and return element Len() - 1. } 除了实现pop和push之外 还需要实现sort接口。\n提供函数 heap接口提供了几个堆操作的函数：\nInit 用于在使用堆之前对堆进行初始化。 1 2 3 4 5 6 7 func Init(h Interface) { // heapify n := h.Len() for i := n/2 - 1; i \u0026gt;= 0; i-- { down(h, i, n) } } Pop/Push 用于弹出或者推入元素 1 2 3 4 5 6 7 8 9 10 11 12 13 // Push 函数将值为 x 的元素推入到堆里面，该函数的复杂度为 O(log(n)) 。 func Push(h Interface, x any) { h.Push(x) up(h, h.Len()-1) } // Pop 函数根据 Less 的结果， 从堆中移除并返回具有最小值的元素。 // 等同于执行 Remove(h, 0)，复杂度为 O(log(n))。（n 等于 h.Len() ）。 func Pop(h Interface) any { n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() } Remove 移除元素 1 2 3 4 5 6 7 8 9 10 func Remove(h Interface, i int) any { n := h.Len() - 1 if n != i { h.Swap(i, n) if !down(h, i, n) { up(h, i) } } return h.Pop() } Fix 有时候我们会修改i上的值，这时需要调用Fix来修复元素顺序。尽管可以先删除i的值，再push，但是直接修改加Fix的成本会小一些。 1 2 3 4 5 func Fix(h Interface, i int) { if !down(h, i, h.Len()) { up(h, i) } } heap包里还有几个关键函数:\nup 将所给索引的元素向上调整到其正确的位置，以满足堆的性质。 down 将所给索引 的元素向下调整至其子节点中合适的位置，保证堆的性质。并且返回是否下沉，即返回true表示发生了下沉，false表示未发生下沉。 使用heap实现一个优先级队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package main import ( \u0026#34;container/heap\u0026#34; \u0026#34;fmt\u0026#34;) // 定义一个实现了heap.Interface的结构体 type PriorityQueue struct { items PriorityQueueItems } type PriorityQueueItem struct { Value int // 具体的值 Priority int // 优先级，这里假设数值越大的优先级越高 index int // 用于heap.Interface所需的索引 } type PriorityQueueItems []PriorityQueueItem // 实现heap.Interface的三个方法 func (pq PriorityQueueItems) Len() int { return len(pq) } func (pq PriorityQueueItems) Less(i, j int) bool { return pq[i].Priority \u0026gt; pq[j].Priority } // 大顶堆 func (pq PriorityQueueItems) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pq *PriorityQueueItems) Push(x interface{}) { n := len(*pq) item := x.(PriorityQueueItem) item.index = n *pq = append(*pq, item) } func (pq *PriorityQueueItems) Pop() interface{} { old := *pq n := len(old) item := old[n-1] old[n-1] = PriorityQueueItem{} *pq = old[0 : n-1] return item } // 优先级队列对外提供的方法 func (pq *PriorityQueue) Push(value int, priority int) { item := PriorityQueueItem{ Value: value, Priority: priority, } heap.Push(\u0026amp;pq.items, item) } func (pq *PriorityQueue) Pop() (value int, ok bool) { if pq.items.Len() == 0 { return 0, false } item := heap.Pop(\u0026amp;pq.items).(PriorityQueueItem) return item.Value, true } func NewPriorityQueue() *PriorityQueue { return \u0026amp;PriorityQueue{items: make(PriorityQueueItems, 0)} } func main() { pq := NewPriorityQueue() pq.Push(3, 1) pq.Push(1, 3) pq.Push(2, 2) for pq.items.Len() \u0026gt; 0 { value, _ := pq.Pop() fmt.Println(value) // 输出顺序应为：3, 2, 1 } } Ring 在 Go 语言的标准库中，container/ring 包提供了环形缓冲区（Ring Buffer）的实现，也称为循环队列。环形缓冲区是一种固定大小的缓冲区，其特点是当缓冲区满时，新的数据会覆盖最旧的数据，形成一个首尾相连的环状结构。这种数据结构常用于缓存最近使用的数据、限流等场景。\n提供函数 New() 创建一个新的环形缓冲区实例，具有给定的大小。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func New(n int) *Ring { if n \u0026lt;= 0 { return nil } r := new(Ring) p := r for i := 1; i \u0026lt; n; i++ { p.next = \u0026amp;Ring{prev: p} p = p.next } p.next = r r.prev = p return r } Link()和Unlink() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // LInk用于连接另一个`ring` func (r *Ring) Link(s *Ring) *Ring { n := r.Next() if s != nil { p := s.Prev() // Note: Cannot use multiple assignment because // evaluation order of LHS is not specified. r.next = s s.prev = r n.prev = p p.next = n } return n } // Unlink用于移除一个元素 func (r *Ring) Unlink(n int) *Ring { if n \u0026lt;= 0 { return nil } return r.Link(r.Move(n + 1)) } Prev() Next() Move() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Prev返回指向前一个元素的环形缓冲区节点 func (r *Ring) Next() *Ring { if r.next == nil { return r.init() } return r.next } // Next返回指向下一个元素的环形缓冲区节点 func (r *Ring) Prev() *Ring { if r.next == nil { return r.init() } return r.prev } // Move将环形缓冲区的指针移动n个位置，正数表示向前移动，负数表示向后移动 func (r *Ring) Move(n int) *Ring { if r.next == nil { return r.init() } switch { case n \u0026lt; 0: for ; n \u0026lt; 0; n++ { r = r.prev } case n \u0026gt; 0: for ; n \u0026gt; 0; n-- { r = r.next } } return r } Len Do 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Len 返回环形缓冲区中有效元素的数量。 func (r *Ring) Len() int { n := 0 if r != nil { n = 1 for p := r.Next(); p != r; p = p.next { n++ } } return n } // Do 对环形缓冲区中的每个元素执行给定的函数 func (r *Ring) Do(f func(any)) { if r != nil { f(r.Value) for p := r.Next(); p != r; p = p.next { f(p.Value) } } ","date":"2024-03-29T22:04:44+08:00","permalink":"https://bitfrost7.git.io/p/golang/container/","title":"Golang学习-container库"},{"content":"哈希表概念 哈希表是一种十分重要的数据结构，具有O(1)的读写速度，并且存储着键值对之间映射关系。\n哈希函数(hash)，也叫做散列函数，本质上是一种抽样函数，好比原来有一长串字符aabbccddeeff，抽样后成了abcdef，所以，哈希函数有个特点：输入范围必然小于输出范围。但在哈希表中，key值往往是无限的，通过哈希计算后必定会出现相同的值，被称为哈希冲突或者哈希碰撞。哈希冲突无法解决，比较实际的方式是通过让哈希函数的结果能够尽可能的均匀分布，但假设发生了哈希冲突，常用的解决方式有两种——开放寻址法和拉链法。\n开发寻址法 开放寻址法是一种解决哈希冲突的方法，这种方法的核心在于依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中，这种方式实现的哈希表底层是一个定长的数组，当我们往哈希表中写入一个数据时：\n根据唯一key计算哈希值\n通过哈希值计算出索引：inedx := hash(key)%len(array)\n索引处若为空直接插入，如果已经有值则找到往后第一个不为空的地方插入\n查找的逻辑相似，主要在于第3步，如果索引处没有找到相应的键值对，则往后遍历直到遍历完或者找到为止。\n开放寻址法的有好处是底层数据架构足够简单，缺点也很明显，当元素个数趋近于数组大小时，哈希表的效率会急速下降，一旦元素个数等于数组大小时，查找一个键值对的复杂度是O(n)，需要遍历整个数组。\n拉链法 拉链法是一种基于数组和链表的结构，数组元素是一个链表，形似拉链。\n当我们写入一个kv时：\n根据唯一key值计算hash值\n通过hash值的低B位 来计算放到那个桶(bucket)里\n如果桶中找到key相同的链表节点则更新该kv对，若非没有找到则在链表结尾追加该kv对\n查找的逻辑类似，于开放寻址法不同，拉链法即使存放元素个数和数组大小相同，查找和存取的效率远远好过开放寻址法。在开放寻址法中，有装载因子这一概念：\n装载因子:= 元素个数 / 桶数量\n拉链法的装载因子越大效率越低，大多数情况下装载因子不会超过1，如果装载因子过大，会触发桶的扩容，设计重新计算hash索引，但即便10的装载因子仍然比O(n)的效率要高。\nGo中map实现 Go语言使用了两个主要结构表示哈希表，hmap和bmap，关于哈希表的结构在$GOROOT\\src\\runtime\\map.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type hmap struct { count int //代表哈希表中的元素个数 flags uint8 B uint8 //哈希表buckets的个数，因为buckets一般是2的倍数，所以B为2的对数 noverflow uint16 hash0 uint32 // hash seed buckets unsafe.Pointer //bucket数组的指针 oldbuckets unsafe.Pointer //哈希表在扩容之前保存之前buckets的指针 nevacuate uintptr extra *mapextra } type mapextra struct { overflow *[]*bmap oldoverflow *[]*bmap nextOverflow *bmap } hmap中存储元素的桶的结构是bmap，每一个bmap中存储着8个kv对，以及8个tophash，当单个桶已经装满时，就会存储到溢出桶overflow中去，当溢出桶也逐渐变多时，也会触发哈希表的扩容。\n1 2 3 4 5 6 7 type bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr } 初始化 在Go中一般使用字面量来初始化哈希表：\n1 2 3 4 m := make(map[string]int, 3) m[\u0026#34;1\u0026#34;] = 2 m[\u0026#34;3\u0026#34;] = 4 m[\u0026#34;5\u0026#34;] = 6 Go初始化一个map的过程主要是以下步骤：\n计算哈希表所占用的内存大小是否溢出\n获取一个随机的哈希种子\n根据kv对的数量来计算桶的数量\n创建桶数组buckets\n创建溢出桶overflow ，此时会根据正常桶的数量来创建溢出桶： 当桶的个数小于2^4时，此时使用溢出桶的可能比较小，会省略创建溢出桶\n当桶的个数大于2^4时，则额外创建2^(B-4)个溢出桶\n溢出桶和正常桶的内存分布是连续的\n读写 哈希表的读主要分为直接获取和遍历：\n1 2 3 4 value := m[key] for k,v := range m{ //k,v } 哈希表的写操作分为：插入，修改和删除:\n1 2 3 m[newkey] = newvalue m[key] = value delete(m,key) 访问 哈希表访问的时候有两种方式，一种是只返回value，还有一种是返回value和一个bool值,来表示哈希表中是否存在这个键值对。\n1 2 v := hashtable[k] v,ok := hashtable[k] 在根据key值查找哈希表时，会经过以下步骤：\n通过哈希表设置的哈希函数、种子获取当前键对应的哈希\n计算该键值对所在的桶序号和哈希高位的 8 位数字 计算桶序号：哈希值低B位，比如说B=5，取低5位00100，也就是第4个桶\n将哈希值高8位和Tophash对比，确定在bucket中那个槽位\n当发现桶中的 tophash 与传入键的 tophash 匹配之后，会通过指针和偏移量获取哈希中存储的键 keys[0]并与 key 比较，如果两者相同就会获取目标值的指针 values[0] 并返回\n当需要返回bool值的时候会根据键值对是否存在再返回，更推荐这种方式。\n当哈希表处于扩容状态时，如果哈希表的 oldbuckets 存在时，对哈希表的访问会先定位到旧桶并在该桶没有被分流时从中获取键值对。\n写入 哈希表在写入时，主要步骤：\n根据key计算hash，找到对应的桶；\n通过hash(key)和tophash进行比较，找到对应的槽位；\n遍历正常桶和溢出桶，如果存在，返回对应val内存地址；如果不存在，则会为新键值对规划存储的内存地址。如果当前桶已经满了，则会创建新的溢出桶来保存数据，同时增加hmap中的noverflow计数器\n扩容 在Go中往哈希表中插入数据时，当桶中的数据过多，原本O(1)的读写效率可能退化到O(n)，这时候就需要扩容，哈希表会在插入新元素的时候进行判断：\n装载因子大于6.5时, 装载因子：loadFactor := count / (2^B)，此时会进行翻倍扩容，扩容后newbuckets = 2^(B+1)\n溢出桶的个数过多时：\n当B小于15时，如果此时溢出桶overflow 的数量超过 2^B，也就是正常桶的数量\n当B大于15时，如果此时溢出桶overflow的数量超过了2^15\n此时会进行等量扩容，因为溢出桶过多说明此时哈希表中进行了大量的插入和删除操作，导致kv分散，降低了哈希表查找的效率。\nGo中哈希表的扩容不是一个原子过程，哈希表会创建一组新桶和溢出桶，再将当前桶挂到hmap中oldbuckets字段，此时并没有对数据进行拷贝，而是在传入数据时将旧桶中的数据进行分流到新桶中去，避免了一次拷贝带来的性能压力，被叫做渐进式扩容。\n哈希表扩容的详细流程：\n当哈希表判断需要进行扩容时，调用hashGrow函数，进入扩容状态，此时会创建新桶和溢出桶，并将当前桶挂到oldbuckets中\n当哈希表调用插入或者删除时，会判断当前哈希表处于扩容状态，并且调用growWork函数进行数据迁移\n在迁移过程中，会根据翻倍扩容还是等量扩容进入不同的迁移流程： 如果是等量扩容，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。\n如果是翻倍扩容，需要重新计算hash，再决定它落在那个桶中，这一阶段会涉及分流:\n举个例子：原始 B = 2，1号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 10 决定它们落在 2 号桶，现在 B 变成 3，所以 010，110 分别落入 2、6 号桶。\n因为迁移的过程并非原子，所以哈希表会在迁移过程中保留一个上下文结构runtime.evacDst，等量扩容为一个，翻倍扩容为两个。\n当哈希表完成扩容之后，会清空oldbuckets，以加速GC。\n删除 哈希表删除需要用到delete关键字，删除的逻辑和插入很类似，如果找不到删除的key值，或者map为空不会进行任何操作，当map处于扩容阶段，会进行桶中元素的分流，分流之后再完成键值对的删除。\n使用嵌套map 在Go中 可以通过类似于map[string]map[string]int这样的方式定义嵌套map，表示声明一个键为string，值为map[string]int的map。\n在Go中使用未初始化的map会panic，所以以下代码会运行报错：\n1 2 3 m := make(map[string]map[string]int) m[\u0026#34;aa\u0026#34;][\u0026#34;b\u0026#34;] = 1 panic: assignment to entry in nil map 正确使用应该先初始化内部map：\n1 2 3 4 m := make(map[string]map[string]int) m[\u0026#34;aa\u0026#34;] = make(map[string]int) m[\u0026#34;aa\u0026#34;][\u0026#34;bb\u0026#34;] = 1 fmt.Println(m) 并发安全的map Go 语言原生 map 并不是线程安全的，对它进行并发读写操作的时候，需要加锁。\n在Go1.9引入了并发安全的map——sync.map。\n使用 sync.map 之后，对 map 的读写，不需要加锁。并且它通过空间换时间的方式，使用 read 和 dirty 两个 map 来进行读写分离，降低锁时间来提高效率。\n1 2 3 4 5 6 type Map struct { mu Mutex read atomic.Value // readOnly dirty map[interface{}]*entry misses int } 使用sync.map GC中的map ","date":"2024-03-29T21:33:25+08:00","permalink":"https://bitfrost7.git.io/p/golang/hashmap/","title":"Golang学习-哈希表"},{"content":"字符串基本使用 声明和初始化字符串 在Go中要声明一个字符串可以这样：\n1 2 3 var s string s := \u0026#34;hello world\u0026#34; s := \u0026#34;你好\u0026#34; //Go也支持中文字符串 格式化输出 在Go中格式化输出字符串主要使用fmt包中的Printf和Sprintf，例如：\n1 2 3 4 a := \u0026#34;世界\u0026#34; fmt.Printf(\u0026#34;hello,%s\u0026#34;, a) str := fmt.Sprintf(\u0026#34;hello,%s\u0026#34;, a) fmt.Println(str) 注意：Sprintf会返回格式化后的字符串，而Printf仅仅只能打印\n字符串编码 Go中字符串使用的是UTF-8编码的Unicode字符序列，需要注意的是在编写Go代码时，需要将编辑器保存设置为UTF-8格式，否则可能会出现编译错误。\n在Go中汉字通常占3个字节，而英文字母只需要1个。\n字符串相关函数 Go中字符串相关的函数都在strings包中\n前缀后缀 1 2 3 4 //判断字符串s前缀是否是prefix HasPrefix(s, prefix string) bool //判断字符串s后缀是否是suffix HasSuffix(s, suffix string) bool 是否包含 1 2 3 4 5 6 //字符串s是否包含子串substr Contains(s string, substr string) bool //字符串是否包含chars内任一字符 ContainsAny(s string, chars string) bool //字符串是否包含某一字符 ContainsRune(s string, r rune) bool 判断索引位置 1 2 3 4 //返回字符串s中第一个substr的位置，如果没有找到返回-1 Index(s, substr string) int //返回字符串s最后一个substr的位置，如果没有找到返回-1 LastIndex(s, substr string) int 字符串替换 1 2 3 4 5 6 7 8 //将字符串s的前n个字符串old替换为new，返回新字符串，如果n=-1则替换所有的new为old Replace(s, old, new string, n int) string //例子: s := \u0026#34;hello,world\u0026#34; new := strings.Replace(s, \u0026#34;l\u0026#34;, \u0026#34;j\u0026#34;, -1) //把s中的所有\u0026#39;l\u0026#39;替换为\u0026#39;j\u0026#39; fmt.Println(s, new) //输出: hello,world hejjo,worjd 字符串计数 1 2 //返回s中出现substr的次数，如果substr为空，则返回len(s)+1 Count(s, substr string) int 大小写转换 1 2 3 4 //将字符串s转换为小写字母返回 ToLower(s string) string //将字符串s转换为大写字母返回 ToUpper(s string) string 修剪字符串 1 2 3 4 5 6 7 8 //剔除掉字符串s前后的cutset Trim(s, cutset string) string //仅剔除字符串s开头的cutset TrimLeft(s, cutset string) string //仅剔除字符串s结尾的cutset TrimRight(s, cutset string) string //剔除字符串s开头结尾的空格 TrimSpace(s string) string 分割和拼接 1 2 3 4 5 6 //将字符串s以空白字符为分隔符切分成数组 Fields(s string) []string //将字符串s以sep为分隔符切分成数组 Split(s, sep string) []string //将字符串数组elems使用sep拼接 返回新字符串 Join(elems []string, sep string) string 字符串底层原理 字符串数据结构 在Go中字符串的底层实际上是一个struct：\n1 2 3 4 type StringHeader struct { Data uintptr Len int } 字符串结构体有一个byte数组指针和一个代表长度的len。\nGo使用\u0026quot;\u0026quot;来声明单行字符串，```来声明多行字符串。\n1 2 3 s1 := \u0026#34;hello world!\u0026#34; s2 := `hello world!` 在Go中string类型是不可变的，在分配内存时会被分配到只读区域，同样在其他语言中字符串类型也是不可变的，这样做的原因是：\n安全：大部分密码都是以字符串形式存储，如果可以修改会造成安全漏洞\n性能：通常HashMap的key一般会是字符串，字符串不可变就能进行hashcode缓存避免重复计算\nGo中并没有字符串常量池这种设计，意味着每次创建相同的字符串会重复分配内存，在某些情况下可能会成为瓶颈，可以自己实现字符串常量池来避免。\n如果需要对字符串强行进行修改，如果字符串只包含ASCII码以内的字符，可以先转换为[]byte类型，在进行修改，再转换为字符串。但是这种方式并没有改变内存中的不可变区域，而是在新的内存区域。\n单引号和双引号的区别 在Go中单引号和双引号是由本质区别的，单引号 — rune类型，其实就相当于int32类型，占4个字节，在Unicode编码中最大4个字节就能表示一个字符。比方说：fmt.Println('a') 结果是97，是ASCII码表中的a的值。双引号—string类型，在Go中双引号表示字符串类型，Go 语言中字符串默认是 UTF-8 编码的 Unicode 字符序列，也就是byte数组\nrune和string异同点 类型 rune（单引号） string（双引号） 底层类型 int32 byte数组 是否能互相转换 是 是 是否可变 不可变 不可变 ","date":"2024-03-29T18:36:49+08:00","permalink":"https://bitfrost7.git.io/p/golang/string/","title":"Golang学习-字符串"},{"content":"Go中的数据类型介绍 在Go中数据类型分为3大类：基础类型，如int，float，bool这些基础类型。内置类型，比如slice，map，channel这些。派生类型，从基础类型或者内置类型组合自定义出来的类型，也可以看作Go中的\u0026quot;对象\u0026quot;。\n字长：计算机CPU总线的位宽，一般有32位和64位，限制了cpu一次能读取的数据\n字节：一位0或者1就是1bit，1byte = 8bit，1024 byte = 1kb， 1024 kb = 1 MB，1024 MB = 1GB 数字类型 在Go中int 类型的大小是根据底层系统的字长决定，32位系统下是4字节，64位系统下是8字节。而固定位数的整型类型有8种:\n类型 描述 大小 表示范围 零值 int8 8 位整型 1字节 -2^7 ~ 2^7-1 0 int16 16位整型 2字节 -2^15 ~ 2^15-1 0 int32 32位整型 4字节 -2^31 ~ 2^31-1 0 int64 64位整型 8字节 -2^63 ~ 2^63-1 0 uint8 无符号8 位整型 1字节 0~255 0 uint16 无符号16位整型 2字节 0 ~ 2^16-1 0 uint32 无符号32位整型 4字节 0~2^31-1 0 uint64 无符号64位整型 8字节 0~2^63-1 0 这8种都与系统无关。好处是节省空间，大小可选择；缺点是移植性不好。\n浮点型 浮点型有2种：\n类型 描述 大小 表示范围 float32 32位浮点型数 4字节 -3.403E38~3.403E38 float64 64位浮点型数 8字节 -1.798E308~1.798E308 计算机中浮点数的保存通常都是近似值，可能因为精度问题而导致比较结果不准确。所以比较浮点数的零值或者两个浮点数是否相等一般采用math.Abs来比较。\n自定义类型 在Go中使用struct 和 type 关键字来自定义类型，这些类型由基本类型组成，Go使用_组合_的概念来替代_对象。_\nGo中结构体的内存排列是紧密的，但也有例外，不同的类型组合可能会导致结构体大小占用不一样。\n内存对齐 CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。 这么设计的目的，是减少 CPU 访问内存的次数，提升 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。\n内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后， 对该变量的访问就是原子的，这个特性在并发场景下至关重要。\n内存对齐提升性能的同时，也需要付出相应的代价。由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以 占用的内存会更大，这也是典型的 空间换时间 策略。\nGo中内存对齐规则(一个字32位下是4字节，64位下是8字节)：\n类型 大小 bool 1 个字节 intN, uintN, floatN, complexN N / 8个字节（例如 float64 是 8 个字节） int, uint, uintptr 1 个字 *T 1 个字 string 2 个字 （数据、长度） []T 3 个字 （数据、长度、容量） map 1 个字 func 1 个字 chan 1 个字 interface 2 个字 （类型、值） example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 1 word(字) = 8byte(字节) // 未对齐 type StructA struct { sex bool // 1字节 对齐到1个字 name string // 16字节 对齐到2个字 age int16 // 2字节 对齐到1个字 } // 对齐 type StructB struct { name string // 16字节 对齐到2个字 age int16 // 2字节 对齐到1个字 sex bool // 1字节 对齐到1个字 } func main() { fmt.Println(\u0026#34;structA length:\u0026#34;, unsafe.Sizeof(structA{})) // output: 32 fmt.Println(\u0026#34;structB length:\u0026#34;, unsafe.Sizeof(structB{})) // output: 24 } ","date":"2024-03-29T18:30:03+08:00","permalink":"https://bitfrost7.git.io/p/golang/type/","title":"Golang学习-基础数据类型"},{"content":"Array数组 Golang中的数组是静态的，存储着一段相同内容的连续空间。\n基本使用 声明和初始化 在Go中数组的初始化主要有两种方式：一种是显示的指定数组大小，另一种是使用[...]自动推导数组大小的方式。\n1 2 arr1 := [3]int{1,2,3} arr2 := [...]int{1,2,3} 以上两种方式运行结果是一样的，后一种方式会在编译期间自动推导成第一种，只是Go为我们提供的语法糖。\nGo编译器在初始化数组时，会根据字面量的多少来进行不同的优化：\n当元素的数量小于或等于4个时，会将数组的元素直接放在栈上。\n当元素的数量大于4个时，会将数组中元素放置在静态区并在运行时取出。\n访问和读写 数组使用arr[n]来访问数组内元素，如果是一些简单的数组或者字符串的越界错误会在编译期间发现，而如果使用变量去访问数组，会在运行时触发程序的错误并导致崩溃退出。\n多维数组使用 在Go多维数组的初始化和一维类似：\n1 arr := [2][3]int{{1,2,3},{4,5,6}} Slice切片 定义和初始化 切片是Go提供的基于array的一种动态数组，其长度并不像数组那样固定，我们可以向切片中追加元素或者进行扩容等操作。\n切片的初始化有三种方式：\n通过下标初始化获得切片或者数组的一部分\n使用字面量初始化新的切片\n使用关键字make来创建切片\n1 2 3 4 slice := arr[2:3] slice := []int{1,2,3} slice := make([]int,3) //make时还可以传入cap参数，当然，Go也会对参数进行校验，cap必须大于等于len 当Go编译器在创建切片时：\n如果切片发生逃逸或者切片的大小或容量特别大时，需要在运行时在堆上创建底层数组和切片。\n当切片特别小时，Go编译器会先在栈上或者静态存储区初始化数组，再通过下标(即第一种arr[2:3]的方式)得到切片。\n在运行时创建切片时，编译器会计算切片所需要的空间并在堆上申请一片连续的内存空间(空间不足会panic)：\n内存大小=元素大小x切片容量\n当内存分配完成，会返回底层数组的引用，并且和长度，容量合并成SliceHeader的结构体\n切片的底层数据结构如下：\n1 2 3 4 5 type SliceHeader struct { Data uintptr // 存储底层数组 Len int // 切片长度 Cap int // 切片分配的空间大小，小于Cap可以直接追加元素。 } 可以发现切片和数组主要不同在于cap字段。\n切片实际上是在数组的基础上加了一层抽象层，切片实际上是底层数组的一个引用，再加上长度和容量，当我们在运行时修改切片的长度和容量时，底层的数组可能会发生变化，而在上层引用看来切片并没有发生变化。\n切片和数组还有一点不同在于：切片只是在编译期间确定元素类型，而数组的编译期间就已经确定好了类型和长度。\n切片的访问 切片通过下标去访问元素：\n1 a := arr[3] //对切片的索引操作实际上会转化为地址的读取 在访问时，Go会进行边界检查,如果超出则会panic。\n切片可以获取长度和容量：\n1 2 3 arr := make([]int,10,20) l := len(arr) c := cap(arr) 切片追加和扩容 在Go中使用append关键字对切片进行扩容, 扩容后会产生一个新的slice结构体，如果赋值回去原变量就相当于对原变量进行了扩容。\n1 2 arr := make([]int,3, 5) arr = append(arr, []int{1, 2}...) 当切片追加元素时，会根据：\n追加后切片长度小于等于容量\n追加后切片长度大于容量\n以及根据返回值是否覆盖原切片进行不同的流程\n如果触发了第二种情况，即容量不足的情况，Go会对切片进行扩容，扩容其实是为切片分配新的内存空间并拷贝原切片中元素的过程。\n在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：\nGo 1.18之前:\n如果期望容量大于当前容量的两倍就会使用期望容量； 如果当前切片的长度小于 1024 就会将容量翻倍； 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量； Go 1.18之后: 切片扩容不再以1024为临界点，而是设定了一个值为256的threshold。在计算完容量之后，会根据容量和元素大小相乘，如果新的切片发生了内存溢出或者请求内存大于上限则会直接panic。 如果期望容量大于当前容量的两倍就会使用期望容量； 当原切片容量 \u0026lt; threshold 的时候，新切片容量变成原来的 2 倍； 当原切片容量 \u0026gt; threshold 的时候，进入一个循环，每次容量增加(旧容量+threshold*3) / 4； 切片拷贝 在Go中使用copy关键字进行切片的复制，实际上底层使用的是对内存的复制。\nGo对切片仅支持append和copy两种操作，需要注意的是在大切片中进行这两种操作会比较消耗资源。\n案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func func1(a []int) { b := make([][]int, 0) for i := 0; i \u0026lt; 10; i++ { t := append(a, i) b = append(b, t) } } // 需要理解到append的底层实现： 1. 判断原切片是否要扩容 2. 如果要扩容，先new一个新的数组，再copy值到新的数组；如果不需要扩容。直接追加元素 3. append操作实际上会生成一个slice结构体，如果赋值回去，原始切片会增加len；如果不赋值回去，则len不变。 func func2() { a := [...]int{0, 1, 2, 3} x := a[:1] // { pointer:-\u0026gt;a len:1 cap: 4} y := a[2:] x = append(x, y...) x = append(x, y...) fmt.Println(a, x) } //需要理解到[:]运算的本质 //实际上是创建一个切片的引用，底层数组还是指向原来切片，但len和cap发生变化。具体看是如何切割。 ","date":"2024-03-29T16:40:30+08:00","permalink":"https://bitfrost7.git.io/p/golang/slice/","title":"Golang学习-数组和切片"},{"content":"关键字 Go共有25个保留关键字\n包管理（2个）： import 用于导入包，这样就可以使用包中被导出的标识符。导入格式如下：\n1 2 3 4 import \u0026#34;fmt\u0026#34; //直接import import f \u0026#34;fmt\u0026#34; //添加包别名 import . \u0026#34;fmt\u0026#34; //代表导入包，使用时不用加包名 import _ \u0026#34;fmt\u0026#34; //不使用包中的标识符，只需要包的副作用（init函数，包级变量...） package 用于声明包的名称，需放在go文件所有代码的最前面。一个包由一个或多个go源文件组成，需放在同一个目录下，且同一个目录下的这些go文件的package的名字只能有一个，且不能为\u0026quot;_\u0026quot;。 package \u0026lt;packagename\u0026gt;\n程序实体声明与定义（8个）： chan 用于声明channel(信道)。信道提供一种机制使两个并发执行的函数实现同步，并通过传递具体元素类型的值来通信。\n1 2 3 chan T // 可以被用来发送和接收类型T的值 chan\u0026lt;- T // 只能被用来发送浮点数 \u0026lt;-chan T // 只能被用来接收整数 const 用于定义常量，一旦创建，不可赋值修改\nfunc func 用于定义函数。Go函数支持可变参数且返回值支持多个，但不支持默认参数。如果函数存在多个返回值形参则需要使用小括号括起来，定义格式如下：\n1 2 3 func funcName(){} //无参无返回值 func funcName(t T) T {} //有参有返回值 func funcName(t T, list ...T) (T1,T1) {} //有变参有多个返回值 interface interface 用于定义接口。一个接口是一个方法集，如果一个类型实现了一个接口中的所有方法集，那么说明该类型实现此接口。接口类型变量可以存储任何实现了该接口的类型的值。特别的，interface{}表示空接口类型，默认地，所有类型均实现了空接口，所以interface{}可以接收任意类型值。\nmap map 用于声明映射变量。映射属容器类类型，是一个同种类型元素的无序组，通过唯一的键可以获取对应的值。可以使用 make 创建 map 变量，在定义 map 时可以省略容量，超出容量时会自动扩容，但尽量提供一个合理的初始值。未初始化的值为 nil。\nstruct struct 用于定义结构体。结构体属容器类型，是多个相同或不同类型值的集合 。一个结构体的零值是类型集合中所有类型的零值。\ntype type 用于定义类型，比如定义 struct、interface、func 与等价类型。\nvar var 用于申明函数级变量和包级变量。\n程序流程控制（15个）： 循环 for 是 Go 中唯一用于循环结构的关键词, 有三种使用方式：1. 单条件 2. 循环变量 3 range\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // for 单条件用法 相当于while i := 0 for i \u0026lt; 10 { fmt.Println(i) i++ } // for 循环变量 for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } // for range 用法 s := []int{1, 2, 3} for i, v := range s { fmt.Println(i, v) } break continue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // break 跳出本次循环 for i := 0; i \u0026lt; 10; i++ { if i == 5 { break } fmt.Println(i) } // continue 跳过本次循环 for i := 0; i \u0026lt; 10; i++ { if i == 5 { continue } fmt.Println(i) } 条件语句 if else else if 1 2 3 4 5 6 7 if i == 1 { fmt.Println(\u0026#34;i == 1\u0026#34;) } else if i == 2 { fmt.Println(\u0026#34;i == 2\u0026#34;) } else { fmt.Println(\u0026#34;i != 1 \u0026amp;\u0026amp; i != 2\u0026#34;) } switch default case\n1 2 3 4 5 6 7 8 switch i { case 1: fmt.Println(\u0026#34;i == 1\u0026#34;) case 2: fmt.Println(\u0026#34;i == 2\u0026#34;) default: fmt.Println(\u0026#34;i != 1 \u0026amp;\u0026amp; i != 2\u0026#34;) } 跳转控制 return Go中一个函数可以有一个或者多个返回值，返回值通过return指定。\nreturn关键字中指定了参数时，返回值可以不用名称。如果return省略参数，则返回值部分必须带名称，当返回值带有名称时，必须使用()包起来 在一个函数块里，任何在return之后的代码都不会执行 defer goto 并发控制 go select ","date":"2024-03-29T15:54:28+08:00","permalink":"https://bitfrost7.git.io/p/golang/","title":"Golang学习-关键字"}]