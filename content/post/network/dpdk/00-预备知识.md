---
title: dpdk学习00—预备知识
slug: /network/dpdk/00
description: 在学习正式dpdk之前，需要了解一些dpdk相关概念以及dpdk中遇到的C语言语法方便阅读代码。
date: 2024-04-01
lastmod: 2024-04-25T02:05:59+08:00
draft: false
toc: true
weight: false
image: ""
categories:
  - ""
  - 计算机网络
  - DPDK
tags:
  - dpdk
---
## 认识dpdk
### 什么是dpdk？
dpdk是intel开源的一个网络加速工具包，目的是在IA平台上解决高性能网络数据包处理的问题。  
传统网络包处理的过程是：
1. 网卡收到数据包
2. 网卡将帧DMA到内存
3. 网卡发送硬中断
4. cpu响应中断，调用对应函数进行收包
5. 将ring buffer保存到skb
6. 内核协议栈处理帧
7. 用户进程处理报文  

因为传统网络包处理是中断驱动的，所以在大量网络请求下会出现irq风暴，降低处理性能。除此之外还涉及到多次用户态和内核态数据拷贝，降低性能。当时流行的做法是通过硬件来加速网络包处理，但是dpdk的产生证明了通用化硬件在软件极致优化的情况下也能做到达到io的极限。
基于IA处理器的DPDK技术，很好地解决高性能数据包处理的问题，这些技术包括：
- 通过轮询来处理数据包，避免中断上下文切换的开销
- 使用用户态驱动，避免内核态到用户态不必要的内存拷贝和系统调用
- 设置cpu亲和性与独占，避免线程在不同核心间频繁切换; 限制某些核心不参与Linux系统调试, 可使线程独占该核心
- 利用大页内存降低TLB miss
### dpdk框架的由来
由于传统包处理任务存在内核态与用户态的切换，以及多次的内存拷贝，系统消耗变大，以CPU为核心的系统存在很大的处理瓶颈。为了提升在通用服务器（COTS）的数据包处理效能，Intel推出了服务于IA（Intel Architecture）系统的DPDK技术。

DPDK是Data Plane Development Kit的缩写。简单说，DPDK应用程序运行在操作系统的User Space，利用自身提供的数据面库进行收发包处理，绕过了Linux内核态协议栈，以提升报文处理效率。
### dpdk的优势和现状
1. 零拷贝架构
2. 轮询模式 vs 中断模式
3. NUMA感知的内存管理
### dpdk的核心组件
- EAL 环境抽象层，EAL是DPDK的基石，提供硬件和操作系统的抽象。完成以下工作：
	- rte_memory，内存管理（大页、NUMA）
    - rte_pci，rte_bus。PCIe 设备发现和绑定
    - rte_lcore，核心和拓扑发现
    - rte_timer，定时器和告警设置
- 内存管理组件，高性能数据包处理的内存基础设施：
	- Mbuf（内存缓冲区）：数据包的核心容器，支持链式存储、零拷贝、硬件卸载元数据    
	- Mempool（内存池）：预分配的对象池，消除运行时内存分配开销
	- 内存分配器：NUMA 感知的内存分配，支持对齐分配
- 网络设备组件，用户态网络驱动和硬件抽象：
	- PMD（轮询模式驱动）：绕过内核，直接操作网卡硬件
	- 设备管理 API：端口配置、队列管理、统计收集
	- Flow API（流分类）：硬件加速的流规则匹配和动作执行
- 无锁数据结构，多核心并行处理的同步原语：
	- Ring（环形队列）：无锁生产者-消费者队列，支持批量操作
	- Hash（哈希表）：无锁哈希表，用于路由表、会话表
	- 其他结构：栈、布隆过滤器、LPM（最长前缀匹配）
- 定时调度，高性能的事件和定时管理：
	- 定时器系统：纳秒精度定时器，支持单次和周期性任务
	- 事件驱动框架（Eventdev）：任务调度、负载均衡、优先级队列
	- 工作队列：任务分发和执行框架
还有安全加密，QoS控制等组件，后续文章再说
## 相关术语介绍
- ACL：Access Control List，访问控制列表，是路由器和交换机接口的指令列表，用来控制端口进出的数据包；简而言之就是用来控制数据流。
- SSL：Secure Sockets Layer，安全套接层，是为网络通信提供安全及数据完整性的一种安全协议，在传输层对网络连接进行加密。
- RSS：Receive Side Scaling，是一种能够在多处理器系统下使接收报文在多个CPU之间高效分发的网卡驱动技术。
- NUMA：Non Uniform Memory Access Architecture，非统一内存访问架构；
- QOS：Quality of Service，服务质量，指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力, 是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。
- NIC：Network Interface Card，网卡，网卡是局域网中最基本的部件之一，它是连接计算机与网络的硬件设备。
- PCI：Peripheral Component Interconnect，计算机一种标准总线，NIC就是使用的这种总线方式。 　　PMD：Poll Mode Drive，轮询模式驱动，DPDK就是采用的这种模式。
- RTE：Run Time Environment，通过PMD实现快速分组处理数据的一个框架。
- MPLS：Multi-Protocol Label Switching，多协议标签交换，是一种用于快速数据包交换和路由的体系，它为网络数据流量提供了目标、路由地址、转发和交换等能力。更特殊的是，它具有管理各种不同形式通信流的机制。
## 前置C语言语法

### 必须理解的C语言技巧

####  容器宏
```c
// 获取结构体成员的偏移量
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)

// 通过成员指针获取包含它的结构体指针（DPDK核心技巧！）
#define container_of(ptr, type, member) ({ \
    const typeof(((type *)0)->member) *__mptr = (ptr); \
    (type *)((char *)__mptr - offsetof(type, member)); })

// 使用示例：
struct my_struct {
    int value;
    struct rte_mbuf mbuf;  // 内嵌成员
};

// 已知 mbuf 指针，找到包含它的 my_struct
struct rte_mbuf *mbuf_ptr = ...;
struct my_struct *parent = container_of(mbuf_ptr, struct my_struct, mbuf);
```
#### 分支预测优化
```c
#include <rte_branch_prediction.h>

// 告诉编译器哪个分支更可能发生
if (likely(x > 0)) {   // 这个分支大概率发生
    // 快速路径
} else {                // 这个分支很少发生
    // 慢速路径
}

// 实际定义：
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
```

#### 位操作宏
```c
// 常用位操作
#define RTE_BIT32(pos) (1U << (pos))
#define RTE_BIT64(pos) (1ULL << (pos))

// 位域操作
#define RTE_FLAG_SET(var, flag)  ((var) |= (flag))
#define RTE_FLAG_CLEAR(var, flag) ((var) &= ~(flag))
#define RTE_FLAG_ISSET(var, flag) (((var) & (flag)) != 0)

// 对齐操作
#define RTE_ALIGN_FLOOR(val, align) ((val) & ~((align) - 1))
#define RTE_ALIGN_CEIL(val, align)  RTE_ALIGN_FLOOR((val) + (align) - 1, align)
#define RTE_ALIGN(val, align)       RTE_ALIGN_CEIL(val, align)
```
#### 内存屏障
```c
#include <rte_atomic.h>

// 编译器屏障（阻止重排序）
#define rte_compiler_barrier() do { asm volatile("" ::: "memory"); } while(0)

// 读写屏障
#define rte_smp_rmb() rte_compiler_barrier()  // 读内存屏障
#define rte_smp_wmb() rte_compiler_barrier()  // 写内存屏障
#define rte_smp_mb()  rte_compiler_barrier()  // 全内存屏障

// 使用示例（无锁编程中必须！）
producer:
    data = prepare_data();
    rte_smp_wmb();          // 确保数据先写入
    flag = 1;               // 再设置标志

consumer:
    while (!flag) ;         // 等待标志
    rte_smp_rmb();          // 确保先读到标志
    use_data(data);         // 再使用数据
```

#### 原子操作
```c
// DPDK 原子操作封装
static inline void rte_atomic16_init(rte_atomic16_t *v, int16_t val);
static inline int16_t rte_atomic16_read(const rte_atomic16_t *v);
static inline void rte_atomic16_set(rte_atomic16_t *v, int16_t new_value);
static inline void rte_atomic16_add(rte_atomic16_t *v, int16_t inc);
static inline void rte_atomic16_sub(rte_atomic16_t *v, int16_t dec);
static inline int16_t rte_atomic16_add_return(rte_atomic16_t *v, int16_t inc);

// 64位版本类似：rte_atomic64_*
```
### DPDK里常见编码模式
#### 内联函数模式
```c
// DPDK 大量使用 static inline 提升性能
static inline uint16_t
rte_eth_rx_burst(uint16_t port_id, uint16_t queue_id,
                struct rte_mbuf **rx_pkts, const uint16_t nb_pkts)
{
    // 简单封装，可能被编译器内联展开
    return (*rte_eth_devices[port_id].rx_pkt_burst)
        (rte_eth_devices[port_id].data->rx_queues[queue_id],
         rx_pkts, nb_pkts);
}
```
#### 函数指针表模式
```c
// 驱动架构：通过函数指针实现多态
struct rte_eth_dev_ops {
    int (*dev_start)(struct rte_eth_dev *dev);
    void (*dev_stop)(struct rte_eth_dev *dev);
    int (*dev_configure)(struct rte_eth_dev *dev);
    // ... 几十个操作函数
};

// 使用时：
dev->dev_ops->dev_start(dev);
```
#### 配置结构体模式
```c
// 零初始化 + 按需设置
struct rte_eth_conf port_conf = {
    .rxmode = {
        .mtu = 9000,
        .max_rx_pkt_len = 9000,
    },
    .txmode = {
        .offloads = DEV_TX_OFFLOAD_MBUF_FAST_FREE,
    },
    .rx_adv_conf = {
        .rss_conf = {
            .rss_key = NULL,
            .rss_hf = ETH_RSS_IP | ETH_RSS_TCP | ETH_RSS_UDP,
        },
    },
};
```
### 必须知道的头文件

```c
// 核心头文件
#include <rte_eal.h>            // EAL 初始化
#include <rte_mbuf.h>           // Mbuf 操作
#include <rte_mempool.h>        // 内存池
#include <rte_ethdev.h>         // 网卡设备
#include <rte_ring.h>           // 无锁队列
#include <rte_hash.h>           // 哈希表
#include <rte_lpm.h>            // LPM 路由

// 工具头文件
#include <rte_log.h>            // 日志系统
#include <rte_debug.h>          // 调试宏
#include <rte_common.h>         // 通用宏
#include <rte_branch_prediction.h> // 分支预测
#include <rte_malloc.h>         // 动态内存
```